(* Copyright (C) 1999-2004 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 * Copyright (C) 1997-1999 NEC Research Institute.
 *
 * MLton is released under the GNU General Public License (GPL).
 * Please see the file MLton-LICENSE for license information.
 *)

type int = Int.t

fun reg (left, right) = Region.make {left = left, right = right}
fun error (reg, msg) = Control.error (reg, Layout.str msg, Layout.empty)

open Ast

fun reportDuplicates (v: 'a vector,
		      name: string,
		      equals: 'a * 'a -> bool,
		      layout: 'a -> Layout.t,
		      region: 'a -> Region.t) =
   Vector.foreachi
   (v, fn (i, a) =>
    let
       fun loop i' =
	  if i = i'
	     then ()
	  else if equals (a, Vector.sub (v, i'))
		  then 
		     let
			open Layout
		     in
			Control.error
			(region a,
			 seq [str (concat ["duplicate ", name, ": "]), layout a],
			 empty)
		     end
	       else loop (i' + 1)
    in
       loop 0
    end)

type fctbinds = {lhs: Fctid.t, rhs: Fctid.t} list
type sigbinds = {lhs: Sigid.t, rhs: Sigid.t} list
type strbinds = {lhs: Strid.t, rhs: Strid.t} list

type basbinds = {name: Basid.t, def: Basexp.t} list

  %%
%term
      ID of string | COMMA | SEMICOLON | EOF
    | AND | BAS | BASIS | END | EQUALOP | FUNCTOR | IN | LET 
    | LOCAL | OPEN | SIGNATURE | STRUCTURE
    | ANN | PRIM | FILE of string

%nonterm
	 ann of string list
       | anns of (string list * Region.t) list
       | anns' of (string list * Region.t) list
       | basbinds of basbinds
       | basbinds' of Basexp.t * basbinds
       | basbinds'' of basbinds
       | basdec of Basdec.t
       | basdecnode of Basdec.node
       | basdecs of Basdec.t
       | basdecsnode of Basdec.node 
       | basexp of Basexp.t
       | basexpnode of Basexp.node
       | basid of Basid.t
       | basids of Basid.t list
       | fctbinds of fctbinds
       | fctbinds' of Fctid.t * fctbinds
       | fctbinds'' of fctbinds
       | fctid of Fctid.t
       | id of Symbol.t * Region.t
       | mlb of Basdec.t
       | sigbinds of sigbinds
       | sigbinds' of Sigid.t * sigbinds
       | sigbinds'' of sigbinds
       | sigid of Sigid.t
       | strbinds of strbinds
       | strbinds' of Strid.t * strbinds
       | strbinds'' of strbinds
       | strid of Strid.t

%verbose
%pos SourcePos.t
%eop EOF
%noshift EOF

%header (functor MLBLrValsFun (structure Token: TOKEN
                               structure Ast: AST
			       val lexAndParseProg: File.t * Region.t -> 
                                                    File.t * Ast.Program.t
			       val lexAndParseMLB: File.t * Region.t -> 
                                                   File.t * OS.FileSys.file_id option * Ast.Basdec.t))

%right AND

%name MLB

%keyword AND BAS BASIS END FUNCTOR IN LET LOCAL OPEN SIGNATURE STRUCTURE ANN PRIM

%change -> SEMICOLON | -> IN ID END

%value ID ("bogus")

%%

mlb : basdecs (basdecs)


basdecs : basdecsnode (Basdec.makeRegion' 
                       (basdecsnode, basdecsnodeleft, basdecsnoderight))

basdecsnode :                    (Basdec.Seq [])
            | SEMICOLON basdecs  (Basdec.Seq [basdecs])
            | basdec basdecs     (Basdec.Seq [basdec, basdecs])

basdec : basdecnode (Basdec.makeRegion'
                     (basdecnode, basdecnodeleft, basdecnoderight))

basdecnode
   : FUNCTOR fctbinds
     (let
         val fctbinds = Vector.fromList fctbinds
         val _ =
            reportDuplicates
            (fctbinds,
             "functor definition",
             fn ({lhs = n, ...}, {lhs = n', ...}) => Fctid.equals (n, n'),
             Fctid.layout o #lhs,
             Fctid.region o #lhs)
      in
         Basdec.Defs (ModIdBind.makeRegion' (ModIdBind.Fct fctbinds, FUNCTORleft, fctbindsright))
      end)
   | SIGNATURE sigbinds
     (let
         val sigbinds = Vector.fromList sigbinds
         val _ =
            reportDuplicates
            (sigbinds,
             "signature definition",
             fn ({lhs = n, ...}, {lhs = n', ...}) => Sigid.equals (n, n'),
             Sigid.layout o #lhs,
             Sigid.region o #lhs)
      in
         Basdec.Defs (ModIdBind.makeRegion' (ModIdBind.Sig sigbinds, SIGNATUREleft, sigbindsright))
      end)
   | STRUCTURE strbinds
     (let
         val strbinds = Vector.fromList strbinds
         val _ =
            reportDuplicates
            (strbinds,
             "structure definition",
             fn ({lhs = n, ...}, {lhs = n', ...}) => Strid.equals (n, n'),
             Strid.layout o #lhs,
             Strid.region o #lhs)
      in
         Basdec.Defs (ModIdBind.makeRegion' (ModIdBind.Str strbinds, STRUCTUREleft, strbindsright))
      end)
   | BASIS basbinds
     (let
         val basbinds = Vector.fromList basbinds
         val _ =
            reportDuplicates
            (basbinds,
             "basis definition",
             fn ({name = n, ...}, {name = n', ...}) => Basid.equals (n, n'),
             Basid.layout o #name,
             Basid.region o #name)
      in
         Basdec.Basis basbinds
      end)
   | LOCAL basdecs IN basdecs END  (Basdec.Local (basdecs1, basdecs2))
   | OPEN basids  (Basdec.Open (Vector.fromList basids))
   | FILE
     (let
	 val reg = reg (FILEleft, FILEright)
         fun err () =
	    (error (reg, "MLton can't process")
             ; Basdec.Seq [])
         val mlbExts = ["mlb"]
         val progExts = ["ML","fun","sig","sml"]
      in
         case File.extension FILE of
	    SOME s =>
	       if List.contains (mlbExts, s, String.equals)
		  then Basdec.MLB (lexAndParseMLB (FILE, reg))
	       else if List.contains (progExts, s, String.equals)
		  then Basdec.Prog (lexAndParseProg (FILE, reg))
	       else err ()
	  | NONE => err ()
      end)
   | PRIM (Basdec.Prim)
   | ANN anns IN basdecs END  (Basdec.Ann (anns, basdecs))

fctbinds : fctid EQUALOP fctbinds'
           (let val (def, fctbinds) = fctbinds'
            in {lhs = fctid, rhs = def}
               :: fctbinds
            end)
         | fctid fctbinds''
           ({lhs = fctid, rhs = fctid} :: fctbinds'')

fctbinds' : fctid fctbinds''  (fctid, fctbinds'')

fctbinds'' :               ([])
           | AND fctbinds  (fctbinds)

sigbinds : sigid EQUALOP sigbinds'
           (let val (def, sigbinds) = sigbinds'
            in {lhs = sigid, rhs = def}
               :: sigbinds
            end)
         | sigid sigbinds''
           ({lhs = sigid, rhs = sigid} :: sigbinds'')

sigbinds' : sigid sigbinds''  (sigid, sigbinds'')

sigbinds'' :               ([])
           | AND sigbinds  (sigbinds)

strbinds : strid EQUALOP strbinds'
           (let val (def, strbinds) = strbinds'
            in {lhs = strid, rhs = def}
               :: strbinds
            end)
         | strid strbinds''
           ({lhs = strid, rhs = strid} :: strbinds'')

strbinds' : strid strbinds''  (strid, strbinds'')

strbinds'' :               ([])
           | AND strbinds  (strbinds)

basbinds : basid EQUALOP basbinds'
           (let val (def, basbinds) = basbinds'
            in {name = basid, def = def}
               :: basbinds
            end)

basbinds' : basexp basbinds''  (basexp, basbinds'')

basbinds'' :               ([])
           | AND basbinds  (basbinds)


basexp : basexpnode (Basexp.makeRegion'
                     (basexpnode, basexpnodeleft, basexpnoderight))

basexpnode : BAS basdecs END           (Basexp.Bas basdecs)
           | basid                     (Basexp.Var basid)
           | LET basdec IN basexp END  (Basexp.Let (basdec, basexp))

basid : id  (Basid.fromSymbol id)
basids : basid ([basid])
       | basid basids (basid :: basids)
fctid : id  (Fctid.fromSymbol id)
sigid : id  (Sigid.fromSymbol id)
strid : id  (Strid.fromSymbol id)
id : ID     (Symbol.fromString ID, reg (IDleft, IDright))

anns : ann anns'  ((ann, reg (annleft, annright))::anns')

anns' :             ([])
      | COMMA anns  (anns)

ann :         ([]) 
    | ID ann  (ID::ann)