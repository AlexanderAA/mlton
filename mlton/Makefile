SRC = $(shell cd .. && pwd)
BUILD = $(SRC)/build
BIN = $(BUILD)/bin
LIB = $(BUILD)/lib
MLTON = mlton
TARGET = self
AOUT = mlton-compile
UP = upgrade-basis.sml
PATH = $(BIN):$(shell echo $$PATH)
ifeq (self, $(shell if [ -x $(BIN)/mlton ]; then echo self; fi))
  # We're compiling MLton with itself, so don't use any stubs.
  CM = mlton.cm
else
ifeq (cygwin, $(shell $(SRC)/bin/host-os))
  # The stubs don't work on Cygwin, since they define spawn in terms of
  # fork, and fork doesn't work on Cygwin.  So, make without the stubs.
  CM = mlton.cm
else
  # We're compiling MLton with an older version of itself, so use the stubs for
  # the MLton structure.
  CM = mlton-stubs.cm
endif
endif

FLAGS = @MLton $(RUNTIME_ARGS) gc-summary --
ifeq (new,$(shell PATH=$(BIN):$$PATH; mlton -target self >/dev/null 2>&1 && echo new))
  FLAGS += -target $(TARGET)
else
  FLAGS += -host $(TARGET)
endif
ifeq (new,$(shell PATH=$(BIN):$$PATH; mlton -verbose 1 >/dev/null 2>&1 && echo new))
  FLAGS += -verbose 1 -output $(AOUT)
else
  FLAGS += -v -o $(AOUT)
endif

SOURCES =			\
	mlton.cm		\
	$(UP)			\
	front-end/ml.lex.sml 	\
	front-end/ml.grm.sig 	\
	front-end/ml.grm.sml	\
	$(shell if [ -r mlton.cm ]; then mlton -stop f mlton.cm; fi)

.PHONY: all
all: $(AOUT)

$(AOUT): $(SOURCES)
	rm -f $(UP)
	$(MAKE) $(UP)
	@echo 'Compiling mlton (takes a while)'
	mlton $(FLAGS) $(CM)
	size $(AOUT)

# We pass the full path to mlton, via `which mlton`, because
# upgrade-basis is written with #!/usr/bin/env sh, which ignores the
# current path.
$(UP):
	$(SRC)/bin/upgrade-basis `which mlton` >$(UP)

mlton.cm: mlton-stubs.cm
	grep -v mlton-stubs mlton-stubs.cm >mlton.cm

# This makes a version of MLton that can be compiled in the standard basis
# library.  I.E. it doesn't require a MLton structure.
.PHONY:	mlton-stubs_cm
mlton-stubs_cm:
	(								\
		echo 'Group is' &&					\
		cmcat sources.cm | grep -v 'basis-stubs' | 		\
			grep -v 'mlton-stubs-in-smlnj' |		\
			grep mlyacc &&					\
		echo '$(UP)' &&						\
		cmcat sources.cm | grep -v 'basis-stubs' | 		\
			grep -v 'mlton-stubs-in-smlnj' |		\
			grep -v mlyacc &&				\
		echo 'call-main.sml';					\
	) >mlton-stubs.cm

mlton.sml: $(SOURCES)
	rm -f mlton.sml && mlton -stop sml mlton.cm && chmod -w mlton.sml

front-end/ml.lex.sml: front-end/ml.lex
	rm -f front-end/ml.lex.sml
	mllex front-end/ml.lex
	chmod -w front-end/ml.lex.sml

front-end/ml.grm.sig front-end/ml.grm.sml: front-end/ml.grm
	rm -f front-end/ml.grm.*
	mlyacc front-end/ml.grm
	chmod -w front-end/ml.grm.*

.PHONY: clean
clean:
	../bin/clean

#
# The following rebuilds the heap file for the SML/NJ compiled version
# of MLton.
# It requires that you have SML/NJ with the Compilation
# Manager (CM) installed.  You may need to replace the following with
# 'sml-cm'.
#
SML	= sml

.PHONY: nj-mlton
nj-mlton: $(SOURCES)
	(									\
		echo 'SMLofNJ.Internals.GC.messages false;';			\
		echo '#set CM.Control.verbose false;';				\
		echo '#set CM.Control.warn_obsolete false;';			\
		echo 'Control.polyEqWarn := false;';				\
		echo 'CM.make "sources.cm";';					\
		echo 'Main.exportNJ ("$(SRC)/basis-library", "$(LIB)/mlton");'	\
	) | $(SML)

.PHONY: nj-mlton-dual
nj-mlton-dual: $(SOURCES)
	(									\
		echo 'SMLofNJ.Internals.GC.messages false;';			\
		echo '#set CM.Control.verbose false;';				\
		echo '#set CM.Control.warn_obsolete false;';			\
		echo 'Control.polyEqWarn := false;';				\
		echo 'val _ = CM.Server.start {cmd = (CommandLine.name (), ["@CMslave"]), name = "server1", pathtrans = NONE, pref = 0};';\
		echo 'val _ = CM.Server.start {cmd = (CommandLine.name (), ["@CMslave"]), name = "server2", pathtrans = NONE, pref = 0};';\
		echo 'CM.make "sources.cm";';					\
		echo 'Main.exportNJ ("$(SRC)/basis-library", "$(LIB)/mlton");'	\
	) | $(SML)

.PHONY: nj-whole
nj-whole: $(SOURCES)
	(									\
		echo 'SMLofNJ.Internals.GC.messages false;';			\
		echo '#set CM.Control.verbose false;';				\
		echo '#set CM.Control.warn_obsolete false;';			\
		echo 'Control.polyEqWarn := false;'; 				\
		echo 'local'; 							\
		cmcat sources.cm | grep 'mlton-stubs-in-smlnj' | xargs cat;	\
		cmcat sources.cm | grep 'mlyacc' | xargs cat;			\
		cmcat sources.cm | grep -v 'mlyacc' |				\
			grep -v 'mlton-stubs-in-smlnj' | xargs cat; 		\
		echo 'in';							\
		echo 'val _ = Main.exportNJ ("$(SRC)/basis-library", "$(LIB)/mlton")';	\
		echo 'end';							\
	) >mlton.whole.sml
	$(SML) <mlton.whole.sml
