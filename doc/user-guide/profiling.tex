\sec{Profiling}{profiling}

{\mlton} has a profiling facility, {\tt mlprof}, that is similar in
usage to {\tt gprof}.  Here is an example run from within the {\tt
  examples/profiling} directory showing how to generate profiling
information.

\begin{verbatim}
% mlton -profile true -keep g profiling.sml
% ./profiling
% mlprof profiling mlmon.out
0.12 seconds of CPU time
tak_0               91.67%
IntInf_smallMul (C)  8.33%
\end{verbatim}
In summary, generating profiling information takes three steps.
\begin{enumerate}
  
\item Compile with {\tt -profile true}.  This saves a {\tt .ssa} file
  (see below).  You can also use {\tt -keep g} to save the generated
  assembly ({\tt .S}) files.
  
\item Run the executable.  This produces a file called {\tt
    mlmon.out}.
  
\item Run {\tt mlprof} on the executable and the {\tt mlmon.out} file.

\end{enumerate}
Unfortunately, the profiling output of {\tt mlprof} {\em
does not refer to the source program}.  Instead, {\tt mlprof} reports the
percentage of time spent in each C and SSA function.  C functions are
used for the FFI and garbage collector.  SSA is an intermediate
language used by MLton that has traditional first-order function
definitions and calls and is similar to static-single assignment form.
In the above example, {\tt tak\_0} is a SSA function (see {\tt
  profiling.ssa}) corresponding to the source SML {\tt tak} function.
The C function {\tt IntInf\_smallMul} is used to implement {\tt
  IntInf.*}.

In translating from SML to SSA, {\mlton} attempts to preserve source
names, but due to anonymous functions, inlining, monomorphisation,
closure conversion, and other optimizations, there is often quite a
difference between the source and the optimized SSA program.  The
source names are always mangled by adding a suffix of {\tt \_n} for
some n (e.g. {\tt tak\_0}).  Names in the source may disappear (e.g.
{\tt f} is nowhere to be found because it has been turned into a loop
within main) or new names may appear from the SML basis library code
that is prefixed to your program.

You can display profiling information at the SSA basic block level
with {\tt mlprof -d 1}.

\begin{verbatim}
% mlprof -d 1 profiling mlmon.out
0.40 seconds of CPU time
tak_0                      90.00%
     loop_0         19.44%       
     L_17           16.67%       
     L_23           13.89%       
     L_22           11.11%       
     L_19            8.33%       
     L_21            8.33%       
     L_20            8.33%       
     L_18            5.56%       
     L_24            5.56%       
     L_15            2.78%       
IntInf_smallMul (C)        10.00%
\end{verbatim}
Each of the indented labels refers to a basic block in {\tt
  profiling.ssa}, within the {\tt tak\_0} function.

You can display profiling information at the assembly basic block
level with {\tt mlprof -d 2}.  Other {\tt mlprof} options are {\tt
  -s}, which will print information about static C functions, {\tt
  -t}, which will limit {\tt mlprof} to only print information about
functions (or blocks) whose percentage of time is above a certain
threshold, and {\tt -x}, which will annotate each percentage of time
with its absolute time.

You may find it useful to use the {\tt -keep dot} switch when
compiling {\tt -profile true}, since this saves the the SSA function
call graph ({\tt .call-graph.dot}) for the whole program.  Also, for
each SSA function {\tt f}, it saves the intraprocedural control-flow
graph ({\tt .f.cfg.dot}) and dominator tree ({\tt .f.dom.dot}).  In
the control-flow graph, solid edges indicate gotos with arguments,
dashed edges indicate handling a raise coming from the callee, and
dotted edges indicate a return from the callee.  Executing {\tt
mlprof} with the {\tt -color} option in the presence of the {\tt
.call-graph.dot} file will color the nodes of the call graph red,
orange, yellow, or black according to the percentage of time spent in
the corresponding SSA functions.  Likewise, executing {\tt mlprof}
with the {\tt -color -d 2} options in the presence of the {\tt
.cfg.dot} files will color the nodes of the control-flow graphs.  Note
that the effect of the {\tt -color} option is dependent upon the {\tt
-t n} option; functions and blocks below the threshold are always
colored black.

\subsection{Using {\tt mlprof} and {\tt MLton.Profile}}
To profile individual portions of your program, use the {\tt
MLton.Profile} structure (see \secref{profile}).
Here is an example run from within the {\tt examples/profiling}
directory showing how to profile the executions of the {\tt fib} and
{\tt tak} functions separately.

\begin{verbatim}
% mlton -p -keep g profiling2.sml
% profiling2
% mlprof profiling2 mlmon.fib.out
14.60 seconds of CPU time
fib_0 100.00%
% mlprof profiling2 mlmon.tak.out
1.67 seconds of CPU time
tak_0 100.00%
% mlprof profiling2 mlmon.fib.out mlmon.tak.out mlmon.out
16.27 seconds of CPU time
fib_0 89.74%
tak_0 10.26%
\end{verbatim}

Executing {\tt mlprof} with multiple {\tt mlmon.out} files sums the
profiling data in each file to produce the output profiling
information.

\subsection{How profiling works}

The profiler works by catching the {\tt SIGPROF} signal 100 times per
second and recording where in the executable the program counter is.
Thus, if you compile {\tt -profile true}, use of the following in your
program will cause a run-time error, since they would interfere with
profiling.

\begin{tabular}{l}
\tt MLton.Itimer.set \{which = MLton.Itimer.Prof, ...\}\\
\tt MLton.Signal.Handler.set (MLton.Signal.prof, ...)
\end{tabular}

It is best to have a long running program (at least tens of seconds)
in order to get reasonable data.
