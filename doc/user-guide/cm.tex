\sec{CM}{cm}{CM.html}
%
For porting code from SML/NJ and for developing code for MLton under
SML/NJ, {\mlton} supports a very limited subset of
\htmladdnormallink{Compilation Manager}
                  {http://www.smlnj.org/doc/CM/index.html}
(CM) files.  From {\mlton}'s point of view, a CM file {\tt foo.cm}
defines a list of SML source files.  The call {\tt mlton foo.cm} is
equivalent to compiling an SML program consisting of the concatenation
of these files.  As always with {\mlton}, the concatenation must be
the whole program you wish to compile.

In its simplest form, a CM file contains the keywords {\tt Group is}
followed by an explicit list of sml files.  For example, if {\tt
foo.cm} contains
\begin{verbatim}
Group is
bar.sig
bar.fun
main.sml
\end{verbatim}
then a call {\tt mlton foo.cm} is equivalent to concatenating the
three files together and calling {\mlton} on that SML file.  The list
of files defined by a CM file is the same as the order in which the
filenames appear in the CM file.  Thus, order in a CM file matters.
In the above example, if {\tt main.sml} refers to a structure defined
in {\tt bar.fun}, then {\tt main.sml} must appear after {\tt bar.fun}
in the file list.

CM files can also refer to other CM files.  A reference to {\tt
bar.cm} from within {\tt foo.cm} means to include all of the SML files
defined by {\tt bar.cm} before any of the subsequent files in {\tt
foo.cm}.  For example if {\tt foo.cm} contains
\begin{verbatim}
Group is
bar.cm
main.sml
\end{verbatim}
and {\tt bar.cm} contains
\begin{verbatim}
Group is
bar.sig
bar.fun
\end{verbatim}
then a call to {\tt mlton foo.cm} is equivalent to compiling the
concatenation of {\tt bar.sig}, {\tt bar.fun}, and {\tt main.sml}.

CM also has a preprocessor mechanism that allows files to be
conditionally included.  This can be useful when developing code with
{\smlnj} and {\mlton}.  In {\smlnj}, the preprocessor defines the
symbol {\tt SMLNJ\_VERSION}.  In {\mlton}, no symbols are defined.
So, to conditionally include {\tt foo.sml} when compiling under
{\smlnj}, one can use the following pattern.
\begin{verbatim}
# if (defined(SMLNJ_VERSION))
foo.sml
# endif
\end{verbatim}
To conditionally include {\tt foo.sml} when comiling under {\mlton}, one can
negate the test.
\begin{verbatim}
# if (! defined(SMLNJ_VERSION))
foo.sml
# endif
\end{verbatim}

The filenames listed in a CM file can be either absolute paths or
relative paths, in which case they are interpreted relative to the
directory containing the CM file.  If a CM file refers either directly
or indirectly to an SML source file in more than one way, only the
first occurrence of the file is included.  Finally, the only valid
file suffixes in a CM file are {\tt .cm}, {\tt .fun}, {\tt .sig}, and
{\tt .sml}.
%
\subsec{Comparison with CM}{comparison}

If you are unfamiliar with CM under {\smlnj}, then you should skip this
section.

{\mlton} supports the full syntax of CM as of {\smlnj} version
110.9.1.  Extensions since then are unsupported.  Also, many of the
syntactic constructs are ignored.  The most important difference
between the two is that order in CM files matters to {\mlton} but not
to CM, which performs automatic dependency analysis.  Also, CM
supports export filters, which restricts the visibility of modules.
{\mlton} ignores export filters.  As a consequence, it is possible
that a program that is accepted by SML/NJ's CM might not be accepted
by MLton's CM.  In this case, you will have to manually reorder the
files and possibly rename modules so that the concatenation of the
files is the program you intend.

CM performs cutoff recompilation to avoid recompiling the entire
program, while {\mlton} always compiles the entire program.  CM makes
a distinction between groups and libraries, which {\mlton} does not.
CM supports other tools like lex and yacc, while {\mlton} does not.
{\mlton} relies on traditional makefiles to use other tools.
%
\subsec{Porting {\smlnj} CM files to {\mlton}}{porting-cm}

If you have already created large projects using {\smlnj} and CM,
there may be a large number of file dependencies implicit in your
sources that are not reflected in your CM files.  Because {\mlton}
relies on ordering in CM files, your CM files probably will not work
with {\mlton}.  To help in porting CM files to {\mlton}, the {\mlton}
distribution includes the sources for a utility, {\tt cmcat}, that
will print an ordered list of files corresponding to a CM file.  See
{\tt \doc/cmcat/cmcat.sml} for details.  Building {\tt cmcat} requires
that you have already installed {\smlnj} version 110.44.

Alternatively, you may convert your CM files to {\tt .mlb} files.  The
{\mlton} distribution includes the sources for a utility, {\tt
cm2mlb}, that will print a ML basis file with essentially the same
semantics as the CM file -- handling the full syntax of CM supported
by your installed {\smlnj} version and correctly handling export
filters.  When {\tt cm2mlb} encounters a {\tt .cm} import, it attempts
to convert it to a corresponding {\tt .mlb} import.  CM anchors are
translated to paths according to a configuration file in {\tt
.mlton/cm2mlb-map} in the user's home directory (which must be given
by the {\tt HOME} environment variable.  For example, adding
\begin{verbatim}
basis  $(MLTON_ROOT)/basis
\end{verbatim}
to your {\tt cm2mlb-map} file will ensure that a {\tt \$/basis.cm}
import is translated to a {\tt \$(MLTON\_ROOT)/basis/basis.mlb} import.
See {\tt \doc/cmcat/cm2mlb} for details.  Building {\tt cm2mlb}
requires that you have already installed {\smlnj} version 110.44.
