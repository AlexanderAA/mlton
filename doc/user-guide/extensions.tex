\sec{{\mlton} extensions}{mlton}{MLton_extensions.html}
%
\subsec{{\nline} directives}{nline}

To aid in the debugging of code produced by program genenerators such as
\htmladdnormallink{Noweb}{http://www.eecs.harvard.edu/~nr/noweb/},
{\mlton} supports comments with {\nline} directives of the form {\tt
(*\#line }{\it line}{\tt.}{\it col} {\tt "}{\it file}{\tt"*)}.  Here,
{\it line} and {\it col} are sequences of decimal digits and {\it
file} is the source file.  A {\nline} directive causes the front end
to believe that the character following the right parenthesis is at
the line and column of the specified file.  A {\nline} directive only
affects the reporting of error messages and does not affect program
semantics (except for functions like {\tt MLton.Exn.history} which
report source file positions).  Syntactically invalid {\nline}
directives are ignored.  To prevent incompatibilites with SML, the
file name may not contain the character sequence {\tt *)}.
%
\subsec{The {\tt MLton} structure}{mlton-ext}

The remainder of this section describes the modules {\mlton} makes
available that are not part of the Standard ML Basis Library.  As a
warning, please keep in mind that the {\tt MLton} structure and its
substructures do change from release to release of {\mlton}.

\begin{verbatim}
structure MLton:
   sig
      val eq: 'a * 'a -> bool
      val isMLton: bool
      val share: 'a -> unit
      val shareAll: unit -> unit
      val size: 'a -> int

      structure Array: MLTON_ARRAY
      structure BinIO: MLTON_BIN_IO
      structure Cont: MLTON_CONT
      structure Exn: MLTON_EXN
      structure Finalizable: MLTON_FINALIZABLE
      structure GC: MLTON_GC
      structure IntInf: MLTON_INT_INF
      structure Itimer: MLTON_ITIMER
      structure Platform: MLTON_PLATFORM
      structure Pointer: MLTON_POINTER
      structure ProcEnv: MLTON_PROC_ENV
      structure Process: MLTON_PROCESS
      structure Profile: MLTON_PROFILE
      structure Random: MLTON_RANDOM
      structure Rlimit: MLTON_RLIMIT
      structure Rusage: MLTON_RUSAGE
      structure Signal: MLTON_SIGNAL
      structure Socket: MLTON_SOCKET
      structure Syslog: MLTON_SYSLOG
      structure TextIO: MLTON_TEXT_IO
      structure Thread: MLTON_THREAD
      structure Vector: MLTON_VECTOR
      structure Weak: MLTON_WEAK
      structure Word: MLTON_WORD where type word = Word.word
      structure Word8: MLTON_WORD where type word = Word8.word
      structure World: MLTON_WORLD
   end
\end{verbatim}
%
\subsubsection{{\tt MLton}}

\newcommand{\entry}[1]{\item[\tt #1]\hspace{1in}\\}
\begin{description}

\entry{eq (x, y)}
returns true if {\tt x} and {\tt y} are equal as pointers.  For simple
types like {\tt char}, {\tt int}, and {\tt word}, this is the same as
equals.  For arrays, datatypes, strings, tuples, and vectors, this is
a simple pointer equality.  The semantics is a bit murky.

\entry{isMLton}
is always true in a {\mlton} implementation, and is always false in a
stub implementation.

\entry{share x}
maximizes sharing in the heap for the object graph reachable from {\tt
x}.

\entry{shareAll ()}
maximizes sharing in the heap by sharing space for equivalent
immutable objects.  A call to {\tt shareAll} performs a major garbage
collection, and takes time proportional to the size of the heap.

\entry{size x}
return the amount of heap space (in bytes) taken by the value of {\tt
x}, including all objects reachable from {\tt x} by following
pointers.  It takes time proportional to the size of {\tt x}.  For an
example, see {\tt examples/size.sml}.

\end{description}

\subsubsec{{\tt MLton.Array}}{array}

\begin{verbatim}
signature MLTON_ARRAY =
   sig
      val unfoldi: int * 'b * (int * 'b -> 'a * 'b) -> 'a array
   end
\end{verbatim}

\begin{description}

\entry{unfoldi (n, b, f)}
construct an array $a$ of a length {\tt n}, whose elements $a_i$ are determined
by the equations $b_0 = b$ and $(a_i, b_{i+1}) = f (i, b_i)$.

\end{description}
%
\subsubsection{{\tt MLton.BinIO}}

\begin{verbatim}
signature MLTON_BIN_IO =
   MLTON_IO
   where type instream = BinIO.instream
   where type outstream = BinIO.outstream
\end{verbatim}

See \secref{mlton-io}.

\subsubsec{{\tt MLton.Cont}}{cont}

\begin{verbatim}
signature MLTON_CONT =
   sig
      type 'a t

      val callcc: ('a t -> 'a) -> 'a
      val prepend: 'a t * ('b -> 'a) -> 'b t
      val throw: 'a t * 'a -> 'b
      val throw': 'a t * (unit -> 'a) -> 'b
   end
\end{verbatim}

\begin{description}

\entry{type 'a t}
the type of continuations that expect a value of type {\tt 'a}.

\entry{callcc f}
apply {\tt f} to the current continuation.  Because this copies the
entire stack, {\tt callcc} takes time proportional to the current
stack size.

\entry{prepend (k, f)}
compose a function {\tt f} with a continuation {\tt k} to create a
continuation that first does {\tt f} and then does {\tt k}.  This
is a constant time operation.

\entry{throw (k, v)}
throw value {\tt v} to continuation {\tt k}.  Because this copies the
entire stack of {\tt k}, {\tt throw} takes time proportional to the
size of this stack.

\entry{throw' (k, th)}
a generalization of throw that evaluates {\tt th ()} in the context
of {\tt k}.  Thus, for example, if {\tt th ()} raises an exception or
grabs another continuation, it will see {\tt k}, not the current
continuation.

\end{description}

\subsubsec{{\tt MLton.Exn}}{exn}

\begin{verbatim}
signature MLTON_EXN =
   sig
      val addExnMessager: (exn -> string option) -> unit
      val history: exn -> string list
      val topLevelHandler: exn -> 'a
   end
\end{verbatim}

\begin{description}

\entry{addExnMessager f}
adds {\tt f} as a pretty-printer to be used by {\tt
General.exnMessage} for converting exceptions to strings.  Messagers
are tried in order from most recently added to least recently added.

\entry{history e}
returns the file positions that have raised the exception {\tt e}, in reverse
chronological order.   A {\tt handle} expression that implicitly reraises counts
as a raise.  {\tt history} will return {\tt []} unless the program is compiled
with {\tt -exn-history true}.

\entry{topLevelHandler e}
behave as if the top level handler received the exception {\tt e},
that is, print out the unhandled exception message for {\tt e} and
exit.

\end{description}

\subsubsec{{\tt MLton.Finalizable}}{finalizable}

\begin{verbatim}
signature MLTON_FINALIZABLE =
   sig
      type 'a t

      val addFinalizer: 'a t * ('a -> unit) -> unit
      val finalizeBefore: 'a t * 'b t -> unit
      val new: 'a -> 'a t
      val touch: 'a t -> unit
      val withValue: 'a t * ('a -> 'b) -> 'b
   end
\end{verbatim}

A finalizable value is a value to which {\em finalizers} can be
attached.  A finalizer is a function that runs after a garbage
collection determines that the value to which it is attached is
unreachable.  Reachability is the same as with weak pointers (see
\secref{weak}).  The finalizer is treated like a signal handler, in
that it runs asynchronously in a separate thread, with signals
blocked, and will not run within a critical section (see
\secref{thread}).

For an example, see the {\tt examples/finalizable} directory.

\begin{description}

\entry{addFinalizer (v, f)}
adds {\tt f} as a finalizer to {\tt v}.  This means that sometime
after the last call to {\tt withValue} on {\tt v} completes and {\tt
v} becomes unreachable, {\tt f} will be called with the value of {\tt
v}.

\entry{finalizeBefore (v1, v2)}
ensures that {\tt v1} will be finalized before {\tt v2}.  A cycle of
values {\tt v} = {\tt v1}, \ldots, {\tt vn} = {\tt v} with {\tt
finalizeBefore (vi, vi+1)} will result in none of the {\tt vi} being
finalized.

\entry{new x}
creates a new finalizable value, {\tt v}, with value {\tt x}.  The
finalizers of {\tt v} will run sometime after the last call to {\tt
withValue} on {\tt v} when the garbage collector determines that {\tt
v} is unreachable.

\entry{touch v}
ensures that {\tt v}'s finalizers will not run before the call to
{\tt touch}.

\entry{withValue (v, f)}
returns the result of applying {\tt f} to the value of {\tt v} and
ensures that {\tt v}'s finalizers will not run before {\tt f}
completes.  The call to {\tt f} is a nontail call.

\end{description}

\subsubsection{{\tt MLton.GC}}

\begin{verbatim}
signature MLTON_GC =
   sig
      val collect: unit -> unit
      val pack: unit -> unit
      val setMessages: bool -> unit
      val setSummary: bool -> unit
      val unpack: unit -> unit
   end
\end{verbatim}

\begin{description}
\entry{collect ()}
causes a garbage collection to occur.

\entry{pack ()}
shrinks the heap as much as possible so that other processes can use
available RAM.

\entry{setMessages b}
controls whether diagnostic messages are printed at the beginning and
end of each garbage collection.  It is the same as the {\tt
gc-messages} runtime system option.

\entry{setSummary b}
controls whether a summary of garbage collection statistics is printed
upon termination of the program.  It is the same as the {\tt
gc-summary} runtime system option.

\entry{unpack ()}
resizes a packed heap to the size desired by the runtime.

\end{description}
%
\subsubsection{{\tt MLton.IntInf}}

\begin{verbatim}
signature MLTON_INT_INF =
   sig
      type t

      val areSmall: t * t -> bool
      val gcd: t * t -> t
      val isSmall: t -> bool
      datatype rep =
         Big of word vector
       | Small of int
      val rep: t -> rep
   end
\end{verbatim}

{\mlton} represents an arbitrary precision integer either as an
unboxed 32 bit word with the bottom bit set to 1 and the top 31 bits
representing a small integer in $[-2^{30}, 2^{30})$, or as a pointer
to a vector of words where the first word indicates the sign and the
rest are the limbs of {\gmp} big integer.

\begin{description}

\entry{type t}
the same as type {\tt IntInf.int}.

\entry{areSmall (a, b)}
returns true iff both {\tt a} and {\tt b} are small.

\entry{gcd (a, b)}
use the {\gmp}'s fast gcd implementation.

\entry{isSmall a}
returns true iff {\tt a} is small.

\entry{datatype rep}
the underlying representation of an IntInf.

\entry{rep i}
return the underlying representation of i.

\end{description}

\subsubsec{{\tt MLTON\_IO}}{mlton-io}

\begin{verbatim}
signature MLTON_IO =
   sig
      type instream
      type outstream

      val inFd: instream -> Posix.IO.file_desc
      val mkstemp: string -> string * outstream
      val mkstemps: {prefix: string, suffix: string} -> string * outstream
      val newIn: Posix.IO.file_desc * string -> instream
      val newOut: Posix.IO.file_desc * string -> outstream
      val outFd: outstream -> Posix.IO.file_desc
   end
\end{verbatim}

\begin{description}

\entry{inFd ins} return the file descriptor corresponding to {\tt ins}.

\entry{mkstemp s}
like the C {\tt mkstemp} function, generate and open a tempory file with prefix
{\tt s}.

\entry{mkstemps \{prefix, suffix\}}
{\tt mkstemps} is like {\tt mkstemp}, except it has both a prefix and suffix.

\entry{newIn (fd, name)} create a new instream from file descriptor
{\tt fd}, with {\tt name} used in any {\tt Io} exceptions later
raised.

\entry{newOut (fd, name)} create a new outstream from file descriptor
{\tt  fd}, with {\tt name} used in any {\tt Io} exceptions later
raised.

\entry{outFd out} return the file descriptor corresponding to
{\tt out}.
\end{description}

\subsubsec{{\tt MLton.Itimer}}{itimer}

\begin{verbatim}
signature MLTON_ITIMER =
   sig
      datatype t =
         Prof
       | Real
       | Virtual

      val set: t * {interval: Time.time, value: Time.time} -> unit
      val signal: t -> Posix.Signal.signal
   end
\end{verbatim}

\begin{description}
\entry{set (t, \{interval, value\})}
set the interval timer (using {\tt setitimer}) specified by {\tt t} to
the given {\tt interval} and {\tt value}.

\entry{signal t}
return the signal corresponding to {\tt t}.
\end{description}
%
\subsubsection{\tt MLton.Platform}

\begin{verbatim}
signature MLTON_PLATFORM =
   sig
      structure Arch:
         sig
            datatype t = PowerPC | Sparc | X86

            val fromString: string -> t option
            val host: t
            val toString: t -> string
         end
         
      structure OS:
         sig
            datatype t = Cygwin | Darwin | FreeBSD | Linux | MinGW
                       | NetBSD | OpenBSD | Solaris

            val fromString: string -> t option
            val host: t
            val toString: t -> string
         end
   end
\end{verbatim}

\begin{description}

\entry{datatype Arch.t}
the architectures to which {\mlton} can compile.

\entry{Arch.fromString a}
convert from string to architecture.  Case insensitive.

\entry{Arch.host}
the architecture for which the program is compiled.

\entry{Arch.toString}
string for architecture.

\entry{datatype OS.t}
the operating systems to which {\mlton} can compile.

\entry{OS.fromString}
convert from string to operating system.  Case insensitive.

\entry{OS.host}
the operating system for which the program is compiled.

\entry{OS.toString}
string for operating system.

\end{description}
%
\subsubsec{\tt MLton.Pointer}{pointer}

\begin{verbatim}
signature MLTON_POINTER =
   sig
      eqtype t

      val add: t * word -> t
      val compare: t * t -> order
      val diff: t * t -> word
      val getInt8: t * int -> Int8.int
      val getInt16: t * int -> Int16.int
      val getInt32: t * int -> Int32.int
      val getInt64: t * int -> Int64.int
      val getPointer: t * int -> t
      val getReal32: t * int -> Real32.real
      val getReal64: t * int -> Real64.real
      val getWord8: t * int -> Word8.word
      val getWord16: t * int -> Word16.word
      val getWord32: t * int -> Word32.word
      val getWord64: t * int -> Word64.word
      val null: t
      val setInt8: t * int * Int8.int -> unit
      val setInt16: t * int * Int16.int -> unit
      val setInt32: t * int * Int32.int -> unit
      val setInt64: t * int * Int64.int -> unit
      val setPointer: t * int * t -> unit
      val setReal32: t * int * Real32.real -> unit
      val setReal64: t * int * Real64.real -> unit
      val setWord8: t * int * Word8.word -> unit
      val setWord16: t * int * Word16.word -> unit
      val setWord32: t * int * Word32.word -> unit
      val setWord64: t * int * Word64.word -> unit
      val sub: t * word -> t
   end
\end{verbatim}

\begin{description}
\entry{eqtype t}
The type of pointers, i.e. machine addresses.

\entry{add (p, w)}
returns the pointer {\tt w} bytes after than {\tt p}.  Does not check
for overflow.

\entry{compare (p1, p2)}
compare the pointer {\tt p1} to the pointer {\tt p2} (as addresses).

\entry{diff (p1, p2)}
returns the number of bytes {\tt w} such that {\tt add (p2, w) = p1}.
Does not check for overflow.

\entry{get\mbox{\it X} (p, i)}
returns the object stored at index i of the array of {\it X} objects
pointed to by {\tt p}.  For example, {\tt getWord32 (p, 7)} returns
the 32-bit word stored 28 bytes beyond {\tt p}.

\entry{null}
the null pointer, i.e. 0.

\entry{set\mbox{\it X} (p, i, v)}
assigns {\tt v} to the object stored at index i of the array of {\it
X} objects pointed to by {\tt p}.  For example, {\tt setWord32 (p, 7,
w)} stores the 32-bit word {\tt w} at the address 28 bytes beyond {\tt
p}.

\entry{sub (p, w)}
returns the pointer {\tt w} bytes before {\tt p}.  Does not check for
overflow.

\end{description}
%
\subsubsection{\tt MLton.ProcEnv}

\begin{verbatim}
signature MLTON_PROC_ENV =
   sig
      val setenv: {name: string, value: string} -> unit
   end
\end{verbatim}

\begin{description}
\entry{setenv \{name, value\}}
Like the C {\tt setenv} function.  Does not require {\tt name} or {\tt
value} to be null terminated.
\end{description}
%
\subsubsection{\tt MLton.Process}

\begin{verbatim}
signature MLTON_PROCESS =
   sig
      type pid = Posix.Process.pid

      val spawn: {path: string, args: string list} -> pid
      val spawne: {path: string, args: string list, env: string list} -> pid
      val spawnp: {file: string, args: string list} -> pid
   end
\end{verbatim}

The {\tt spawn} functions provide an alternative to the {\tt
fork}/{\tt exec} idiom that is typically used to create a new process.
On most platforms, the {\tt spawn} functions are simple wrappers
around {\tt fork}/{\tt exec}.  However, on Cygwin, the {\tt spawn}
functions are primitive and are both faster and more reliable than
{\tt fork}/{\tt exec}.  All {\tt spawn} functions return the process
id of the spawned process.  They differ in how the executable is found
and the environment that it uses.

\begin{description}
\entry{spawn \{path, args\}}
Start a new process running the executable specified by {\tt path} with the
arguments {\tt args}.  Like {\tt Posix.Process.exec}.
\entry{spawne \{path, args, env\}}
Start a new process running the executable specified by {\tt path} with the
arguments {\tt args} and environment {\tt env}.  Like {\tt Posix.Process.exece}.
\entry{spawnp \{file, args\}}
Search the {\tt PATH} environment variable for an executable named {\tt file},
and start a new process running that executable with the arguments {\tt args}.
Like {\tt Posix.Process.execp}.
\end{description}

\subsubsec{{\tt MLton.Profile}}{profile-structure}

\begin{verbatim}
signature MLTON_PROFILE =
   sig
      structure Data:
         sig
            type t

            val equals: t * t -> bool
            val free: t -> unit
            val malloc: unit -> t
            val write: t * string -> unit
         end

      val isOn: bool
      val withData: Data.t * (unit -> 'a) -> 'a
   end
\end{verbatim}

{\tt MLton.Profile} provides profiling control from within the
program.  For more on profiling, see \secref{profiling}.  In order to
most efficiently execute non-profiled programs, when compiling {\tt
-profile no} (the default), type {\tt Data.t} is equivalent to {\tt
unit ref}.

\begin{description}

\entry{isOn}
a compile-time constant that is true when compiling {\tt -profile
time} or {\tt -profile alloc}.

\entry{type Data.t} the type of a unit of profiling data.

\entry{Data.equals (x, y)}
returns true if the {\tt x} and {\tt y} are the same unit of profiling
data.

\entry{Data.free x}
frees the memory associated with the unit of profiling data {\tt x}.
It is an error to free the current unit of profiling data or to free a
previously freed unit of profiling data.  When compiling {\tt -profile
no}, {\tt Data.free x} is a no-op.

\entry{Data.malloc ()}
returns a new unit of profiling data.  Each unit of profiling data is
allocated from the process heap (\emph{not} the {\mlton} heap) and
consumes memory proportional to the number of source functions.  When
compiling {\tt -profile no}, {\tt Data.malloc ()} is equivalent to
allocating a new {\tt unit ref}.

\entry{\tt write (x, f)}
writes the accumulated ticks in the unit of profiling data {\tt x} to
file {\tt f}.  It is an error to write a previously freed unit of
profiling data.  When compiling {\tt -profile no}, {\tt write (x, f)}
is a no-op.  A program compiled with {\tt -profile time} or {\tt
-profile alloc} will always write the current unit of profiling data
at program exit to a file named {\tt mlmon.out}.

\entry{withData (d, f)}
runs {\tt f} with {\tt d} as the unit of profiling data, and returns
the result of {\tt f} after restoring the current unit of profiling
data.  When compiling {\tt -profile no}, {\tt withData (d, f)} is
equivalent to {\tt f ()}.

\end{description}
%
\subsubsection{\tt MLton.Random}

\begin{verbatim}
signature MLTON_RANDOM =
   sig
      val alphaNumChar: unit -> char
      val alphaNumString: int -> string
      val rand: unit -> word
      val seed: unit -> word option
      val srand: word -> unit
      val useed: unit -> word option
   end
\end{verbatim}

\begin{description}
\entry{alphaNumChar ()}
returns a random alphanumeric character.

\entry{alphaNumString n}
return a string of length {\tt n} of random alphanumeric characters.

\entry{rand ()}
return the next pseudrandom number.

\entry{seed ()}
return a random word from {\tt /dev/random}.  Useful as an arg to {\tt
srand}.  If {\tt /dev/random} can not be read from, {\tt seed ()}
returns {\tt NONE}.  A call to {\tt seed} may block until enough
random bits are available.

\entry{srand w}
set the seed used by {\tt rand} to {\tt w}.

\entry{useed ()}
return a random word from {\tt /dev/urandom}.  Useful as an arg to
{\tt srand}.  If {\tt /dev/urandom} can not be read from, {\tt useed
()} returns {\tt NONE}.  A call to {\tt useed} will never block -- it
will instead return lower quality random bits.

\end{description}
%
\subsubsection{\tt MLton.Rlimit}

\begin{verbatim}
signature MLTON_RLIMIT =
   sig
      type rlim = word
               
      val infinity: rlim

      type t
               
      val coreFileSize: t        (* CORE    max core file size *)
      val cpuTime: t             (* CPU     CPU time in seconds *)
      val dataSize: t            (* DATA    max data size *)
      val fileSize: t            (* FSIZE   Maximum filesize *)
      val lockedInMemorySize: t  (* MEMLOCK max locked address space *)
      val numFiles: t            (* NOFILE  max number of open files *)  
      val numProcesses: t        (* NPROC   max number of processes *)
      val residentSetSize: t     (* RSS     max resident set size *)
      val stackSize: t           (* STACK   max stack size *)
      val virtualMemorySize: t   (* AS      virtual memory limit *)
      
      val get: t -> {hard: rlim, soft: rlim}
      val set: t * {hard: rlim, soft: rlim} -> unit
   end
\end{verbatim}

{\tt MLton.Rlimit} provides a wrapper around the C {\tt getrlimit} and
{\tt setrlimit} functions.

\begin{description}
\entry{type rlim}
the type of resource limits.

\entry{infinity}
indicates that a resource is unlimited.

\entry{type t}
the types of resources that can be inspected and modified.

\entry{get r}
returns the current hard and soft limits for resource {\tt r}. May
raise {\tt OS.SysErr}.

\entry{set (r, \{hard, soft\})}
sets the hard and soft limits for resource {\tt r}.  May raise {\tt OS.SysErr}.
\end{description}
%
\subsubsection{\tt MLton.Rusage}

\begin{verbatim}
signature MLTON_RUSAGE =
   sig
      type t = {utime: Time.time, (* user time *)
                stime: Time.time} (* system time *)
         
      val rusage: unit -> {children: t,
                           gc: t,
                           self: t}
   end
\end{verbatim}

\begin{description}
\entry{type t}
corresponds to a subset of the C {\tt struct rusage}.

\entry{rusage ()}
corresponds to the C {\tt getrusage} function.  It returns the
resource usage of the exited children, the garbage collector, and the
process itself.  The process time ({\tt self}) includes the gc time.
\end{description}

\subsubsec{{\tt MLton.Signal}}{signal}

\begin{verbatim}
signature MLTON_SIGNAL =
   sig
      type t
      type signal = t

      structure Handler:
         sig
            type t

            val default: t
            val handler: (Thread.Runnable.t -> Thread.Runnable.t) -> t
            val ignore: t
            val isDefault: t -> bool
            val isIgnore: t -> bool
            val simple: (unit -> unit) -> t
         end

      structure Mask:
         sig
            type t
               
            val all: t
            val allBut: signal list -> t
            val block: t -> unit
            val getBlocked: unit -> t
            val isMember: t * signal -> bool
            val none: t
            val setBlocked: t -> unit
            val some: signal list -> t
            val unblock: t -> unit
         end

      val getHandler: t -> Handler.t
      val handled: unit -> Mask.t
      val prof: t
      val restart: bool ref
      val setHandler: t * Handler.t -> unit
      val suspend: Mask.t -> unit
      val vtalrm: t
   end
\end{verbatim}

Signals handlers are functions from (runnable) threads to (runnable)
threads.  When a signal handler is invoked, it receives as an argument
the thread that was interrupted by the signal.  The signal handler
returns the thread that it would like to resume execution (this is
often the thread that it was passed).  It is an error for a signal
handler to raise an unhandled exception.

A signal handler is never invoked while the running thread is in a
critical section (see \secref{thread}).  Invoking a signal handler
implicitly enters a critical section and the normal return of a signal
handler implicitly exits the critical section; hence, a signal handler
is never interrupted by another signal handler.

Signal handling interacts in a non-trivial way with those functions in
the Basis Library that correspond directly to interruptable system
calls (a subset of those functions that may raise {\tt OS.SysError}).
The desire is that these functions should have predictable semantics.
The principal concerns are:
\begin{enumerate}
\item 
  system calls that are interrupted by signals should, by default, be
  restarted; the alternative is to raise {\tt
    OS.SysError(Posix.Error.errorMsg Posix.Error.intr, SOME
    Posix.Error.intr)}.  This behavior is determined dynamically by
  the value of {\tt Signal.restart}.
\item 
  signal handlers should always get a chance to run (when outside a
  critical region).  If a system call is interrupted by a signal, then
  the signal handler will run before the call is restarted or {\tt
    OS.SysError} is raised; that is, before the {\tt Signal.restart}
  check.
\item 
  a system call that must be restarted while in a critical section
  will be restarted with the handled signals blocked (and the
  previously blocked signals remembered).  This encourages the system
  call to complete, allowing the program to make progess towards
  leaving the critical section where the signal can be handled.  If
  the system call completes, the set of blocked signals are restored
  to those previously blocked.
\end{enumerate}

\begin{description}

\entry{type t} the type of signals.

\entry{type Handler.t}
the type of signal handlers.

\entry{Handler.default}
handles the signal with the default action.

\entry{Handler.handler f}
returns a handler {\tt h} such that when a signal {\tt s} is handled
by {\tt h}, {\tt f} will be passed the thread that was interrupted by
{\tt s} and should return the thread that will resume execution.

\entry{Handler.ignore}
is a handler that will ignore the signal.

\entry{Handler.isDefault}
returns true if the handler is the default handler.

\entry{Handler.isIgnore}
returns true if the handler is the ignore handler.

\entry{Handler.simple f}
returns a handler that executes {\tt f ()} and does not switch
threads.

\entry{type Mask.t}
the type of signal masks, which are sets of blocked signals.

\entry{Mask.all}
a mask of all signals.

\entry{Mask.allBut l}
a mask of all signals except for those in {\tt l}.

\entry{Mask.block m}
block all signals in {\tt m}.

\entry{Mask.getBlocked ()}
get the signal mask {\tt m}, i.e. a signal is blocked if and only
if it is in {\tt m}.

\entry{Mask.isMember (m, s)}
returns true if the signal {\tt s} is in {\tt m}.

\entry{Mask.none}
a mask of no signals.

\entry{Mask.setBlocked m}
set the signal mask to {\tt m}, i.e. a signal is blocked if and only
if it is in {\tt m}.

\entry{Mask.some l} 
a mask of the signals in {\tt l}.

\entry{Mask.unblock m} 
unblock all signals in {\tt m}.

\entry{getHandler s}
returns the current handler for signal {\tt s}.

\entry{handled} 
returns the signal mask {\tt m} corresponding to the currently handled
signals; i.e., a signal is handled if and only if it is im {\tt m}.

\entry{prof}
{\tt SIGPROF}, the profiling signal.

\entry{restart}
dynamically determines the behavior of interrupted system calls; when
{\tt true}, interrupted system calls are restarted; when {\tt false},
interrupted system calls raise {\tt OS.SysError}.

\entry{setHandler (s, h)}
sets the handler for signal {\tt s} to {\tt h}.

\entry{suspend m}
temporarily sets the signal mask to {\tt m} and suspends until an
unmasked signal is received and handled, at which point {\tt suspend} resets
the mask and returns.

\entry{vtalrm}
{\tt SIGVTALRM}, the signal for virtual timers.
\end{description}
%
\subsubsection{{\tt MLton.Socket}}

\begin{verbatim}
signature MLTON_SOCKET =
   sig
      structure Address:
         sig
            type t = word
         end
      structure Host:
         sig
            type t = {name: string}

            val getByAddress: Address.t -> t option
            val getByName: string -> t option
         end
      structure Port:
         sig
            type t = int
         end

      type t

      val accept: t -> Address.t * Port.t * TextIO.instream * TextIO.outstream
      val connect: string * Port.t -> TextIO.instream * TextIO.outstream
      val listen: unit -> Port.t * t
      val listenAt: Port.t -> t
      val shutdownRead: TextIO.instream -> unit
      val shutdownWrite: TextIO.outstream -> unit
   end
\end{verbatim}

This module contains a bare minimum of functionality to do TCP/IP
programming.  This module is implemented on top of the {\tt Socket}
module of the Standard Basis Library.  We encourage you to use the
standard {\tt Socket} module, since we may eliminate {\tt
MLton.Socket} some day.

\begin{description}

\entry{type Address.t}
the type of IP addresses.

\entry{Host.getByAddress a}
lookup the hostname (using {\tt gethostbyaddr}) corresponding to {\tt a}.

\entry{Host.getByName s}
lookup the hostname (using {\tt gethostbyname}) corresponding to {\tt s}.

\entry{type Port.t}
the type of TCP ports.

\entry{type t}
the type of sockets.

\entry{accept s}
accept a connection on socket {\tt s} and return the address and
port of the connecting socket, as well as streams corresponding to the
connection.

\entry{connect (h, p)}
connect to host {\tt h} on port {\tt p}, returning the streams
corresponding to the connection.

\entry{listen ()}
listen to a port chosen by the system.  Returns the port and the socket.

\entry{listenAt p}
listen to port {\tt p}.  Returns the socket.

\entry{shutdownRead ins}
cause the read part of the socket associated with {\tt ins} to be shutdown.

\entry{shutdownWrite out}
cause the write part of the socket associated with {\tt out} to be shutdown.
\end{description}
%
\subsubsection{\tt MLton.Syslog}

\begin{verbatim}
signature MLTON_SYSLOG =
   sig
      type openflag
         
      val CONS     : openflag
      val NDELAY   : openflag
      val PERROR   : openflag
      val PID      : openflag

      type facility

      val AUTHPRIV : facility
      val CRON     : facility
      val DAEMON   : facility
      val KERN     : facility
      val LOCAL0   : facility
      val LOCAL1   : facility
      val LOCAL2   : facility
      val LOCAL3   : facility
      val LOCAL4   : facility
      val LOCAL5   : facility
      val LOCAL6   : facility
      val LOCAL7   : facility
      val LPR      : facility
      val MAIL     : facility
      val NEWS     : facility
      val SYSLOG   : facility
      val USER     : facility
      val UUCP     : facility

      type loglevel

      val EMERG    : loglevel
      val ALERT    : loglevel
      val CRIT     : loglevel
      val ERR      : loglevel
      val WARNING  : loglevel
      val NOTICE   : loglevel
      val INFO     : loglevel
      val DEBUG    : loglevel

      val closelog: unit -> unit
      val log: loglevel * string -> unit
      val openlog: string * openflag list * facility -> unit
   end
\end{verbatim}

{\tt MLton.Syslog} is a complete interface to the system logging
facilities.  See {\tt man 3 syslog} for more details.

\begin{description}
\entry{closelog ()}
close the connection to the system logger.

\entry{log (l, s)}
log message {\tt s} at a loglevel {\tt l}.

\entry{openlog (name, flags, facility)}
open a connection to the system logger. {\tt name} will be prefixed to each
message, and is typically set to the program name.

\end{description}
%
\subsubsection{{\tt MLton.TextIO}}

\begin{verbatim}
signature MLTON_TEXT_IO =
   MLTON_IO
   where type instream = TextIO.instream
   where type outstream = TextIO.outstream
\end{verbatim}

See \secref{mlton-io}.

\subsubsec{{\tt MLton.Thread}}{thread}

\begin{verbatim}
signature MLTON_THREAD =
   sig
      structure AtomicState :
         sig
            datatype t = NonAtomic | Atomic of int
         end
      val atomicBegin: unit -> unit
      val atomicEnd: unit -> unit
      val atomically: (unit -> 'a) -> 'a
      val atomicState: unit -> AtomicState.t

      structure Runnable :
         sig
            type t
         end

      type 'a t

      val new: ('a -> unit) -> 'a t
      val prepend: 'a t * ('b -> 'a) -> 'b t
      val prepare: 'a t * 'a -> Runnable.t
      val switch: ('a t -> Runnable.t) -> 'a
      val atomicSwitch: ('a t -> Runnable.t) -> 'a
   end
\end{verbatim}

Threads are data structures that represent a paused computation.
Runnable threads are threads that will begin or continue computing when
{\tt switch}ed to.  {\tt MLton.Thread} does not include a default
scheduling mechanism, but it can be used to implement both preemptive
and non-preemptive threads.  For examples, see {\tt thread1.sml} and
{\tt thread2.sml} in the {\tt examples} directory.

\begin{description}

\entry{type AtomicState.t}
the type of atomic states.

\entry{atomicBegin ()}
begin a critical section.

\entry{atomicEnd ()}
end a critical section.

\entry{atomically f}
runs {\tt f} in a critical section.

\entry{atomicState ()}
return the current atomic state.

\entry{type Runnable.t}
the type of threads that can be resumed.

\entry{type 'a t}
the type of threads that expect a value of type {\tt 'a}.

\entry{new f}
create a new thread that, when run, applies {\tt f} to the value given
to the thread.  {\tt f} must terminate by {\tt switch}ing to another
thread or exiting the process.

\entry{prepend (t, f)}
create a new thread (destroying {\tt t} in the process) that first
applies {\tt f} to the value given to the thread and then continues
with {\tt t}.  This is a constant time operation.

\entry{prepare (t, v)}
prepare a new runnable thread (destroying {\tt t} in the process)
that will evaluate {\tt t} on {\tt v}.

\entry{switch f}
apply {\tt f} to the current thread to get {\tt rt}, and then start
running thread {\tt rt}.  It is an error for {\tt f} to
perform another {\tt switch}.  {\tt f} is guaranteed to run
atomically.

\entry{atomicSwitch f}
as {\tt switch}, but assumes an atomic calling context.  Upon {\tt
switch}ing back to the current thread, an implicit {\tt atomicEnd} is
performed.

\end{description}
%
\subsubsection{\tt MLton.Vector}

\begin{verbatim}
signature MLTON_VECTOR =
   sig
      val unfoldi: int * 'b * (int * 'b -> 'a * 'b) -> 'a vector
   end
\end{verbatim}

\begin{description}

\entry{unfoldi (n, b, f)}
construct a vector $v$ of a length {\tt n}, whose elements $v_i$ are determined
by the equations $b_0 = b$ and $(v_i, b_{i+1}) = f (i, b_i)$.

\end{description}

\subsubsec{\tt MLton.Weak}{weak}
\begin{verbatim}
signature MLTON_WEAK =
   sig
      type 'a t

      val get: 'a t -> 'a option
      val new: 'a -> 'a t
   end
\end{verbatim}

A weak pointer is a pointer to an object that is nulled if the
object becomes unreachable due to garbage collection.  The weak
pointer does not itself cause the object it points to be retained by
the garbage collector -- only other strong pointers can do that.
For objects that are not allocated in the heap, like integers, a weak
pointer will always be nulled.  So, if {\tt w: int Weak.t} then
{\tt Weak.get w = NONE}.

\begin{description}
\entry{type 'a t}
the type of weak pointers to objects of type {\tt 'a}

\entry{get w}
returns {\tt NONE} if the object pointed to by {\tt w} no longer
exists.  Otherwise, returns {\tt SOME} of the object pointed to by
{\tt w}.

\entry{new x}
returns a weak pointer to {\tt x}.
\end{description}
%
\subsubsection{\tt MLton.Word, MLton.Word8}

\begin{verbatim}
signature MLTON_WORD =
   sig
      type t
         
      val rol: t * word -> t
      val ror: t * word -> t
   end
\end{verbatim}

\begin{description}
\entry{type t}
the type of words.  For {\tt MLton.Word} this is {\tt Word.word}, for
{\tt MLton.Word8} this is {\tt Word8.word}.

\entry{rol (w, w')}
rotate left (circular).

\entry{ror (w, w')}
rotate right (circular).
\end{description}

\subsubsec{{\tt MLton.World}}{world}

\begin{verbatim}
signature MLTON_WORLD =
   sig
      datatype status = Clone | Original

      val load: string -> 'a
      val save: string -> status
      val saveThread: string * Thread.Runnable.t -> unit
   end
\end{verbatim}

\begin{description}
\entry{datatype status}
used to specify whether a world is original or restarted (a clone).

\entry{load f}
load the saved computation from file {\tt f}.

\entry{save f}
save the entire state of the computation to
the file {\tt f}.  The computation can then be restarted at a later
time using {\tt World.load} or the {\tt load-world} runtime system
option.  The call to {\tt save} in the original computation returns
{\tt Original} and the call in the restarted world returns {\tt
Clone}.  The following example is a transcript run in the {\tt
examples/save-world} directory.
\begin{verbatim}
% mlton save-world.sml
% save-world
I am the original
% save-world @MLton load-world world --
I am the clone
\end{verbatim}

\entry{saveThread (f, rt)}
save the entire state of the computation to
the file {\tt f} that will resume with thread {\tt rt} upon restart.

\end{description}
%
\subsec{{\tt SMLofNJ: SML\_OF\_NJ}}{sml-nj-ext}

\begin{verbatim}
signature SML_OF_NJ =
   sig
      structure Cont:
         sig
            type 'a cont
            val callcc: ('a cont -> 'a) -> 'a
            val throw: 'a cont -> 'a -> 'b
         end
      structure SysInfo:
         sig
            exception UNKNOWN
            datatype os_kind = BEOS | MACOS | OS2 | UNIX | WIN32

            val getHostArch: unit -> string
            val getOSKind: unit -> os_kind
            val getOSName: unit -> string
         end

      val exnHistory: exn -> string list
      val exportFn: string * (string * string list -> OS.Process.status) -> unit
      val exportML: string -> bool
      val getAllArgs: unit -> string list
      val getArgs: unit -> string list
      val getCmdName: unit -> string
   end
\end{verbatim}

{\tt SMLofNJ} implements a subset of the structure of the same name
provided in Standard ML of New Jersey.  It is included to make it
easier to port programs between the two systems.  The semantics of
these functions may be different than in {\smlnj}.

\begin{description}

\entry{structure Cont} implements continuations.

\entry{SysInfo.getHostArch ()}
returns the string for the architecture.

\entry{SysInfo.getOSKind}
returns {\tt UNIX}.

\entry{SysInfo.getOSName ()}
returns the string for the host.

\entry{exnHistory}
the same as {\tt MLton.Exn.history}.

\entry{getCmdName ()}
the same as {\tt CommandLine.name ()}.

\entry{getArgs ()}
the same as {\tt CommandLine.arguments ()}.

\entry{getAllArgs ()}
the same as {\tt getCmdName() :: getArgs()}.

\entry{exportFn f}
save the state of the computation to a file that will apply {\tt f} to
the command-line arguments upon restart.

\entry{exportML f}
save the state of the computation to file {\tt f} and continue.
Return {\tt true} in the restarted computation and {\tt false} in the
continuing computation.

\end{description}
%
\subsec{{\tt Unsafe: UNSAFE}}{unsafe-ext}

This module is a subset of the {\tt Unsafe} module provided by
{\smlnj}.

\begin{verbatim}
signature UNSAFE_MONO_ARRAY =
   sig
      type array
      type elem

      val create: int -> array
      val sub: array * int -> elem
      val update: array * int * elem -> unit
   end

signature UNSAFE_MONO_VECTOR =
   sig
      type elem
      type vector

      val sub: vector * int -> elem
   end

signature UNSAFE =
   sig
      structure Array:
         sig
            val create: int * 'a -> 'a array
            val sub: 'a array * int -> 'a
            val update: 'a array * int * 'a -> unit
         end
      structure CharArray: UNSAFE_MONO_ARRAY
      structure CharVector: UNSAFE_MONO_VECTOR
      structure Real64Array: UNSAFE_MONO_ARRAY
      structure Vector:
         sig
            val sub: 'a vector * int -> 'a
         end
      structure Word8Array: UNSAFE_MONO_ARRAY
      structure Word8Vector: UNSAFE_MONO_VECTOR
   end
\end{verbatim}
