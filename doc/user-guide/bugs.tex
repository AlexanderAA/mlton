\sec{Bugs}{bugs}{Bugs.html}
%
\subsection{Reporting a bug}

To report a bug, please send mail to {\mltonmail}.  Please include the
complete SML program that caused the problem and a log of a compile of
the program with {\tt -verbose 2}.
%
\subsection{Unresolved bugs}

This section lists the known places where MLton deviates from the
Definition of SML.

\begin{itemize}

\item
{\mlton} rejects datatype declarations with type variables bound at
an outer level.  For example, the following program is rejected,
although it is allowed by the Definition.
\begin{verbatim}
fun 'a f (x : 'a) =
   let datatype t = T of 'a * int
   in 13
   end
\end{verbatim}
This may be an oversight in the Definition, since unchecked use of
this feature can lead to type unsoundness.

\item
{\mlton} allows local type names to escape their scope, and so accepts
the programs like the following, while the Definition, for technical
reasons, rejects them.
\begin{verbatim}
let
   datatype t = T
in
   T
end
\end{verbatim}

\item
{\mlton} does not enforce the restriction that types must be defined
before they are implicitly used.  So, {\mlton} accepts programs like
the following, while the Definition, for technical reasons, rejects
them.
\begin{verbatim}
val r = ref NONE
datatype t = T
val _ = r := SOME T
\end{verbatim}
%
\item
{\mlton} allows rebinding of constructors with {\tt val rec}
declarations, as in
\begin{verbatim}
val rec NONE = fn x => x;
\end{verbatim}
The Definition requires this program to type check, but to raise {\tt
Bind}.

\item
{\mlton} does not hide the equality aspect of types declared in
{\tt abstype} declarations.  So, {\mlton} accepts programs like the
following, while the Definition rejects them.
\begin{verbatim}
abstype t = T with end
val _ = fn (t1, t2 : t) => t1 = t2
\end{verbatim}

\begin{verbatim}
abstype t = T with val a = T end
val _ = a = a
\end{verbatim}

One consequence of this choice is that {\mlton} accepts the following
program, in accordance with the Definition.
\begin{verbatim}
abstype t = T with val eq = op = end
val _ = fn (t1, t2 : t) => eq (t1, t2)
\end{verbatim}
Other implementations will typically reject this program, because they
make an early choice for the type of {\tt eq} to be {\tt ''a * ''a ->
bool} instead of {\tt t * t -> bool}.  The choice is understandable,
since because the Definition accepts the following program.
\begin{verbatim}
abstype t = T with val eq = op = end
val _ = eq (1, 2)
\end{verbatim}

\end{itemize}
