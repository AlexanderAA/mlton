\sec{Foreign function interface (FFI)}{ffi}

{\mlton}'s FFI is {\em not} part of Standard ML and it is quite
possible that this interface will change.  That having been said, with
{\mlton} it is easy to access C global variables and to make calls
from SML to C and from C to SML, at least when dealing with simple
types like {\tt char}, {\tt int}, {\tt real}, and {\tt word}.

\subsection{Calling from SML to C}
Suppose you would like SML to call a C function with the following
prototype:
\begin{verbatim}
int foo (double d, unsigned char c);
\end{verbatim}
{\mlton} extends the syntax of SML to allow expressions like the following:
\begin{verbatim}
_ffi "foo": real * char -> int;
\end{verbatim}
This expression denotes a function of type {\tt real * char -> int}
whose behavior is implemented by calling the C function whose name is
{\tt foo}.  Thinking in terms of C, imagine that there are C
variables {\tt d} of type {\tt double}, {\tt c} of type {\tt unsigned
char}, and {\tt i} of type {\tt int}.  Then, the C statement
\mbox{\tt i = foo(d, c)} is executed and {\tt i} is returned.

The general form of an \verb+_ffi+ expresion is:
\begin{center}
{\tt \_ffi "}C global variable or function name{\tt ": }ty{\tt ;}
\end{center}
The semicolon is not optional.

An example in the {\tt examples/ffi} directory demonstrates the use of
{\ffi} expressions.  The {\tt Makefile} demonstrates how to call
{\mlton} to include and link with the appropriate files.  Running {\tt
make import} will produce an executable, {\tt import}, that should
output {\tt success} when run.

\begin{verbatim}
% make import
mlton -stop o ffi-import.c
mlton import.sml ffi-import.o
% import
13
success
\end{verbatim}

\subsection{Calling from C to SML}
Suppose you would like export from SML a funtion of type {\tt real *
char -> int} as the C function {\tt foo}.  {\mlton} extends the syntax
of SML to allow expressions like the following:
\begin{verbatim}
_export "foo": real * char -> int;
\end{verbatim}
This expression exports a C function named {\tt foo}, with prototype
\begin{verbatim}
Int32 foo (Real64 x0, Char x1);
\end{verbatim}
The {\export} expression denotes a function of type {\tt (real * char
-> int) -> unit}, that when called with a function {\tt f} arranges
for the exported {\tt foo} function to call {\tt f} when {\tt foo} is
called.  So, for example, the following expression both exports and
defines {\tt foo}.
\begin{verbatim}
_export "foo": real * char -> int;
(fn (x, c) => 13 + Real.floor x + Char.ord c)
\end{verbatim}

{\mlton} generate a C header file at compile time with prototypes for
all of the exported functions.  You can use this header to type check
your C code.  An example in the {\tt examples/ffi} directory
demonstrates the use of {\export} expressions and the header file.
Running {\tt make export} will produce an executable, {\tt export},
that should output {\tt success} when run.

\begin{verbatim}
% make export
mlton export.sml ffi-export.c
% ./export
g starting
i = 13  r = 17.15
g done  char = g
g starting
i = 13  r = 17.15
g done  char = g
g2 starting
g2 done
0wxFF
g3 starting
hello
g3 done
success
\end{verbatim}

Notice that {\tt ffi-export.c} includes {\tt export.h}, the header
file generated by {\mlton}.

\subsection{FFI types}

{\mlton} only allows a values of certain SML types to be passed
between SML and C.  The following types are allowed: {\tt bool}, {\tt
char}, {\tt int}, {\tt real}, {\tt string}, {\tt word}.  Strings are
not null terminated, unless you manually do so from the SML side.  All
of the different sizes of integers, reals, and words are supported as
well: {\tt Int32.int}, {\tt Real64.real}, {\tt Word8.word}, {\tt
Word32.word}.  Arrays, refs, and vectors of the above types are also
allowed.  Because in {\mlton}, monomorphic arrays and vectors are
exactly the same as their polymorphic counterpart these are also
allowed.  Unfortunately, passing tuples or datatypes is not allowed
because that would interfere with representation optimizations.

The file {\tt types.h} in the MLton include directory includes
typedefs for the C types corresponding to the SML types.
Here is the mapping between SML types and C types.

\begin{center}
\begin{tabular}{lll}
SML type & C typedef & C type\\
\hline
{\tt array} & {\tt Pointer} & {\tt char *} \\
{\tt bool} & {\tt Bool} & {\tt long} \\
{\tt char} & {\tt Char} & {\tt unsigned char} \\
{\tt int} & {\tt Int32} & {\tt long} \\
{\tt real} & {\tt Real64} & {\tt double} \\
{\tt ref} & {\tt Pointer} & {\tt char *} \\
{\tt string} & {\tt Pointer} & {\tt char *} \\
{\tt vector} & {\tt Pointer} & {\tt char *} \\
{\tt Word8.word} & {\tt Word8} & {\tt unsigned char} \\
{\tt word} & {\tt Word32} & {\tt unsigned int} \\
\end{tabular}
\end{center}

Although the C type of an array, ref, or vector is always {\tt
Pointer}, in reality, the object is layed out in the natural C
representation.  Your C code should cast to the appropriate C type if
you want to keep the C compiler from complaining.

\subsection{Type checking programs that use {\tt \_ffi}}

Because {\mlton} has relaxed type checking, it is necessary to
type check programs that use {\tt \_ffi} with another SML compiler.
This can be done by a standard process using a Makefile and {\tt sed}.
Suppose that you have a file, {\tt mlxtest.cm}, that describes your
{\mlton} project, and that it refers to a file, {\tt mlx.sml}, that
uses {\tt \_ffi}.  The following Makefile will let you type-check your
code with {\smlnj} by typing {\tt make typecheck}.

\begin{verbatim}
nj: *.sml *.cm
        cat mlx.sml | sed -e 's/_ffi/Unsafe.cast/' >mlx-nj.sml
        cat mlxtest.cm | sed -e 's/mlx.sml/mlx-nj.sml/' >sources.cm

typecheck: nj
        echo "CM.make();" | sml
\end{verbatim}

The basic trick is to replace {\ffi} with {\tt Unsafe.cast} to generate a new
program that SML/NJ likes.  Instead of {\tt Unsafe.cast}, you could also use
anything of type {\tt string -> 'a}, like {\tt raise Match} or a looping
function.  Since all {\ffi} declarations are annotated with their types, the
cast is constrained to the actual type of the foreign function or primitive. Of
course, you should never actually run the code, but it's sufficient for type
checking.
