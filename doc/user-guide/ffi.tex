\sec{Foreign function interface (FFI)}{ffi}

{\mlton}'s FFI is {\em not} part of Standard ML and it is quite possible that
this interface will change.  That having been said, it is easy to access C
global variables and make calls to C functions from within SML using {\mlton},
at least when dealing with simple types like {\tt char}, {\tt double}, {\tt
int}, and {\tt word}.  It is not possible to call C macros or to call SML from
C.

Suppose you would like to call a C function with the following prototype
from SML:
\begin{verbatim}
int foo(double d, unsigned char c);
\end{verbatim}
{\mlton} extends the syntax of SML to allow expressions like the following:
\begin{verbatim}
_ffi "foo": real * char -> int;
\end{verbatim}
This expression denotes a function of type {\tt real * char -> int}
whose behavior is implemented by calling the C function whose name is
{\tt foo}.  Thinking in terms of C, imagine that there are C
variables {\tt d} of type {\tt double}, {\tt c} of type {\tt unsigned
char}, and {\tt i} of type {\tt int}.  Then, the C statement
\mbox{\tt i = foo(d, c)} is executed and {\tt i} is returned.

The general form of an \verb+_ffi+ declaration is:
\begin{verbatim}
_ffi "C global variable or function name": ty;
\end{verbatim}
The semicolon is not optional.  Here is a grammar for the types that
are currently allowed.
\[
\begin{array}{lcl}
\production{\mbox{ty}}
	   {u \alt t\ \mbox{\tt *}\ \ldots\ \mbox{\tt *}\ t\ \mbox{\tt ->}\ u}
\production{t}
	   {u \alt u\ \mbox{\tt array} \alt u\ \mbox{\tt ref}
             \alt u\ \mbox{\tt vector}}
\production{u}
	   {\mbox{\tt bool} \alt \mbox{\tt char} \alt \mbox{\tt int} \alt \mbox{\tt real} \alt \mbox{\tt string} \alt \mbox{\tt unit} \alt \mbox{\tt word} \alt \mbox{\tt word8}}
\end{array}
\]
Here is the mapping between SML types and C types.
\begin{center}
\begin{tabular}{ll}
SML type & C type\\
\hline
{\tt bool} & {\tt int} (0 is false, nonzero is true) \\
{\tt char} & {\tt unsigned char} \\
{\tt int} & {\tt int} \\
{\tt real} & {\tt double} \\
{\tt string} & {\tt char *} \\
{\tt unit} & {\tt void} \\
{\tt word} & {\tt unsigned int} \\
{\tt word8} & {\tt unsigned char} \\
{\tt u array} & {\tt char *} \\
{\tt u ref} & {\tt char *} \\
{\tt u vector} & {\tt char *} \\
\end{tabular}
\end{center}
Passing or returning tuples or datatypes is not allowed because the
representation of these is decided late in the compilation
process and because many optimizations can cause the representation to
change.  Arrays, refs, and vectors may only be passed as arguments and
not returned as results because C functions are not allowed to
allocate in the SML heap.  Although the C type of an array, ref, or
vector is always {\tt char*}, in reality, the object is layed out in
the natural C representation.
%You are responsible for doing the cast
%if you want to keep the C compiler from complaining.
Strings are just
like char arrays, and are not null terminated, unless you manually do
so from the SML side.

% This section is no longer relevant, with the changes in place for
% cross compiling.  Let's wait and see what we actually add before updating
% the docs
%\subsec{Compile-time constants}{compile-time-constant}

%{\mlton}'s \verb+_prim+ facility provides access to compile-time constants,
%which can be defined either via C include ({\tt .h}) files or on the command
%line with the {\tt -D} command-line option.
%The facility supports constants of type {\tt bool}, {\tt int}, {\tt real},
%{\tt string}, and {\tt word}.
%For example, the basis library
%implementation contains the following lines.
%\begin{verbatim}
%type syserror = int
%val acces = _prim "Posix_Error_acces": syserror;
%\end{verbatim}
%This defines the SML variable {\tt acces} to be an int whose value is the value
%of the C constant (macro) \verb+Posix_Error_access+, which is obtained from the
%(automatically) included file {\tt posix-constants.h}.  At compile-time, {\mlton}
%generates a C file that prints the values of all \verb+_prim+ constants, calls
%{\tt gcc} to produce an executable, runs the executable, and reads the result.
%The \verb+_prim+ expressions are then replaced by appropriate constants, which
%are available to the rest of the compilation process.

\subsection{Type checking programs that use {\tt \_ffi}}

Because {\mlton} has poor type checking, it is necessary to type check programs
that use {\tt \_ffi} with another SML compiler.  This can be done by a standard
process using a Makefile and {\tt sed}.  Suppose that you have a file, {\tt
mlxtest.cm}, that describes your {\mlton} project, and that it refers to a file,
{\tt mlx.sml}, that uses {\tt \_ffi}.  The following Makefile will let you
type-check your code with {\smlnj} by typing {\tt make typecheck}.

\begin{verbatim}
nj: *.sml *.cm
        cat mlx.sml | sed -e 's/_ffi/Unsafe.cast/' >mlx-nj.sml
        cat mlxtest.cm | sed -e 's/mlx.sml/mlx-nj.sml/' >sources.cm

typecheck: nj
        echo "CM.make();" | sml
\end{verbatim}

The basic trick is to replace {\ffi} with {\tt Unsafe.cast} to generate a new
program that SML/NJ likes.  Instead of {\tt Unsafe.cast}, you could also use
anything of type {\tt string -> 'a}, like {\tt raise Match} or a looping
function.  Since all {\ffi} declarations are annotated with their types, the
cast is constrained to the actual type of the foreign function or primitive. Of
course, you should never actually run the code, but it's sufficient for type
checking.

\subsection{Example}

The example in the {\tt examples/ffi} directory demonstrates the use of
{\ffi} declarations.  The {\tt Makefile} demonstrates how
to call {\mlton} to include and link with the appropriate files.  Running {\tt
make} should produce an executable, {\tt ffi}, which should output {\tt success}
when run.
%You should also read \secref{compile-time-options} to familiarize
%yourself with the {\mlton} options governing include files and linking ({\tt
%-include}, {\tt -I}, {\tt -l}, and {\tt -L}).

\begin{verbatim}
% mlton -stop o ffi.c
% mlton main.sml ffi.o
% main
13
success
\end{verbatim}
