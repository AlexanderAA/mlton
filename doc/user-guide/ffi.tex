\sec{Foreign function interface (FFI)}{ffi}

{\mlton}'s FFI is {\em not} part of Standard ML and it is quite
possible that this interface will change.  That having been said, with
{\mlton} it is easy to access C global variables and to make calls
from SML to C and from C to SML, at least when dealing with simple
types like {\tt char}, {\tt int}, {\tt real}, and {\tt word}.

\subsection{Calling from SML to C}
Suppose you would like SML to call a C function with the following
prototype:
\begin{verbatim}
int foo (double d, unsigned char c);
\end{verbatim}
{\mlton} extends the syntax of SML to allow expressions like the following:
\begin{verbatim}
_import "foo": real * char -> int;
\end{verbatim}
This expression denotes a function of type {\tt real * char -> int}
whose behavior is implemented by calling the C function whose name is
{\tt foo}.  Thinking in terms of C, imagine that there are C
variables {\tt d} of type {\tt double}, {\tt c} of type {\tt unsigned
char}, and {\tt i} of type {\tt int}.  Then, the C statement
\mbox{\tt i = foo(d, c)} is executed and {\tt i} is returned.

The general form of an \verb+_import+ expresion is:
\begin{center}
{\tt \_import "}C global variable or function name{\tt "}{\it attribute}
...{\tt : }{\it ty}{\tt ;}
\end{center}
The semicolon is not optional.

The function name is followed by a (possiblye empty) sequence of
``attributes'', analogous to C {\tt\_\_attribute\_\_} specifiers.  For
now, the only attributes supported are {\tt cdecl} and {\tt stdcall}.
These specify the calling convention of the C function on a
Cygwin/Windows system, and are ignored on all other systems.  The
default is {\tt cdecl}.  But you must use {\tt stdcall} in order to
correctly call Windows API functions.

An example in the {\tt examples/ffi} directory demonstrates the use of
{\ffi} expressions.  The {\tt Makefile} demonstrates how to call
{\mlton} to include and link with the appropriate files.  Running {\tt
make import} will produce an executable, {\tt import}, that should
output {\tt success} when run.

\begin{verbatim}
% make import
mlton -stop o ffi-import.c
mlton import.sml ffi-import.o
% import
13
success
\end{verbatim}

\subsec{Calling from C to SML}{export}
Suppose you would like export from SML a function of type {\tt real *
char -> int} as the C function {\tt foo}.  {\mlton} extends the syntax
of SML to allow expressions like the following:
\begin{verbatim}
_export "foo": real * char -> int;
\end{verbatim}
As with {\tt \_import}, a sequence of attributes may follow the
function name.  The above expression exports a C function named {\tt
foo}, with prototype
\begin{verbatim}
Int32 foo (Real64 x0, Char x1);
\end{verbatim}
The {\export} expression denotes a function of type {\tt (real * char
-> int) -> unit}, that when called with a function {\tt f} arranges
for the exported {\tt foo} function to call {\tt f} when {\tt foo} is
called.  So, for example, the following expression both exports and
defines {\tt foo}.
\begin{verbatim}
_export "foo": real * char -> int;
(fn (x, c) => 13 + Real.floor x + Char.ord c)
\end{verbatim}

{\mlton}'s {\tt -export-header true} option generates a C header file
with prototypes for all of the functions exported from SML.  Include
this header file in your C files to type check calls to functions
exported from SML.  This header file includes {\tt typedef}s for the
types that can be passed between SML and C, as described in the next
section.  An example in the {\tt examples/ffi} directory demonstrates
the use of {\export} expressions and generating the header file.
Running {\tt make export} will produce an executable, {\tt export},
that should output {\tt success} when run.

\begin{verbatim}
% make export
mlton -export-header true export.sml >export.h
gcc -c ffi-export.c
mlton export.sml ffi-export.o
% ./export
g starting
...
g4 (0)
success
\end{verbatim}

Notice that {\tt ffi-export.c} includes {\tt export.h}, the header
file generated by {\mlton}.

\subsection{FFI types}

{\mlton} only allows a values of certain SML types to be passed
between SML and C.  The following types are allowed: {\tt bool}, {\tt
char}, {\tt int}, {\tt real}, {\tt string}, {\tt word}.  Strings are
not null terminated, unless you manually do so from the SML side.  All
of the different sizes of integers, reals, and words are supported as
well: {\tt Int8.int}, {\tt Int16.int}, {\tt Int32.int}, {\tt
Real64.real}, {\tt Word8.word}, {\tt Word32.word}.  Arrays, refs, and
vectors of the above types are also allowed.  Because in {\mlton}
monomorphic arrays and vectors are exactly the same as their
polymorphic counterpart, these are also allowed.  Unfortunately,
passing tuples or datatypes is not allowed because that would
interfere with representation optimizations.

The C header file that {\tt -export-header true} generates includes
{\tt typedef}s for the C types corresponding to the SML types.  Here
is the mapping between SML types and C types.

\begin{center}
\begin{tabular}{lll}
SML type & C typedef & C type\\
\hline
{\tt array} & {\tt Pointer} & {\tt char *} \\
{\tt bool} & {\tt Int32} & {\tt long} \\
{\tt char} & {\tt Word8} & {\tt unsigned char} \\
{\tt Int8.int} & {\tt Int8} & {\tt char} \\
{\tt Int16.int} & {\tt Int16} & {\tt short} \\
{\tt int} & {\tt Int32} & {\tt long} \\
{\tt real} & {\tt Real64} & {\tt double} \\
{\tt ref} & {\tt Pointer} & {\tt char *} \\
{\tt string} & {\tt Pointer} & {\tt char *} \\
{\tt vector} & {\tt Pointer} & {\tt char *} \\
{\tt Word8.word} & {\tt Word8} & {\tt unsigned char} \\
{\tt word} & {\tt Word32} & {\tt unsigned int} \\
\end{tabular}
\end{center}

Although the C type of an array, ref, or vector is always {\tt
Pointer}, in reality, the object is layed out in the natural C
representation.  Your C code should cast to the appropriate C type if
you want to keep the C compiler from complaining.

\subsection{Type checking programs that use {\tt \_import}}

Because {\mlton} has relaxed type checking, it is necessary to
type check programs that use {\tt \_import} with another SML compiler.
This can be done by a standard process using a Makefile and {\tt sed}.
Suppose that you have a file, {\tt mlxtest.cm}, that describes your
{\mlton} project, and that it refers to a file, {\tt mlx.sml}, that
uses {\tt \_import}.  The following Makefile will let you type-check your
code with {\smlnj} by typing {\tt make typecheck}.

\begin{verbatim}
nj: *.sml *.cm
        cat mlx.sml | sed -e 's/_import/Unsafe.cast/' >mlx-nj.sml
        cat mlxtest.cm | sed -e 's/mlx.sml/mlx-nj.sml/' >sources.cm

typecheck: nj
        echo "CM.make();" | sml
\end{verbatim}

The basic trick is to replace {\ffi} with {\tt Unsafe.cast} to generate a new
program that SML/NJ likes.  Instead of {\tt Unsafe.cast}, you could also use
anything of type {\tt string -> 'a}, like {\tt raise Match} or a looping
function.  Since all {\ffi} declarations are annotated with their types, the
cast is constrained to the actual type of the foreign function or primitive. Of
course, you should never actually run the code, but it's sufficient for type
checking.
