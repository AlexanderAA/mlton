\sec{Features of {\mlton}}{features}{Features_MLton.html}
%
\newcommand{\feature}[1]{\item[\bf #1]\hspace{1in}\\}
%
\begin{description}
\feature{whole-program optimization}
Because {\mlton} compiles the whole program at once, it can perform optimization
across module boundaries.  As a consequence, {\mlton} can reduce or eliminate
the run-time penalty that arises with separate compilation of SML features such
as functors, modules, polymorphism, and higher-order functions.  {\mlton} takes
advantage of having the entire program to perform transformations such as:
defunctorization, monomorphisation, higher-order control-flow analysis,
inlining, unboxing, argument flattening, redundant-argument removal, constant
folding, and representation selection.  Whole-program compilation is an integral
part of the design of {\mlton} and is not likely to change.

\feature{supports the full SML 97 language}
{\mlton} compiles the Standard ML language as given in The Definition
of Standard ML (Revised)\cite{MTHM97}.  If there is a program that is
valid according to The Definition that is rejected by {\mlton}, it is
a bug.  For a list of known bugs, see \secref{bugs}.

\feature{complete basis library}
{\mlton} implements the latest Standard ML basis library
specification, with a complete implementation of all the required
modules, as well as many of the optional modules.  See
\secref{basis-library} for details.

\feature{excellent running times}
{\mlton} generates executables with excellent running times.
For a comparison with other SML compilers, see
\link{\makeurl{performance.html}}.

\feature{native integers and words}
In {\mlton}, integers and words are 32 bits and arithmetic does not have
any overhead due to tagging.

\feature{unboxed native arrays}
In {\mlton}, an array (or vector) of integers, words, or reals uses
the natural C-like representation.  This is fast and supports easy
exchange of data with C.  Monomorphic arrays (and vectors) use the
same C-like representations as their polymorphic counterparts.

\feature{runtime system supports large arrays}
In {\mlton}, array lengths can be up to $2^{31} - 1$, the largest possible
twos-complement 32 bit integer.

\feature{support for large files}
In {\mlton}, file positions and sizes are 64-bit integers, so files
can be as large as is supported by the platform.

\feature{several garbage collection strategies}
The {\mlton} runtime system uses copying, mark-compact, and generational
collection, automatically deciding which to use based on the amount of live
data relative to the amount of RAM.  The runtime system tries to keep the heap
within RAM if at all possible.

\feature{standalone executables}
{\mlton} generates standalone executables.  No additional code or
libraries are necessary in order to run an executable, except for
the standard shared libraries.  {\mlton} can also generate statically
linked executables.

\feature{small executables}
Because of whole-program compilation, {\mlton} can use very aggressive 
dead-code elimination, which often leads to smaller executables than
with other SML compilers.

\feature{compiles large programs}
{\mlton} is sufficiently robust that it can compile large programs,
including itself (over 100K lines) and the
\htmladdnormallink
  {ML Kit Version 3}
  {http://www.itu.dk/research/mlkit/kit3/readme.html}
(75K lines).
The distributed version of {\mlton} was compiled by {\mlton}.

\feature{fast {\tt IntInf} based on GNU multiprecision library}
The {\mlton} implementation of arbitrary precision arithmetic (the
{\tt IntInf} structure) uses the
\htmladdnormallink{GNU multiprecision library ({\gmp})}
		  {http://www.gnu.org/software/gmp/gmp.html}.
Hence, for {\tt IntInf} intensive programs, {\mlton} can be an order
of magnitude or more faster than {\poly} or {\smlnj}.

\feature{simple and fast C FFI}
{\mlton} has a straightforward and fast FFI for calling from SML to C
and from C to SML.  See \secref{ffi} for details.

\feature{source-level profiling of allocation and time}
{\mlton} and {\mlprof} provide source-level profiling information.
See \secref{profiling} for details.

\feature{useful libraries}
{\mlton} has a collection of libraries that provide useful functionality that
cannot be implemented with the standard basis library.  See below for an
overview and \secref{mlton} for details.

\begin{description}

\feature{continuations}
{\mlton} supports continuations via {\tt callcc} and {\tt throw}.

\feature{finalization}
{\mlton} supports finalizable values of arbitrary type.

\feature{interval timers}
{\mlton} supports the functionality of the C {\tt setitimer} function.

\feature{random numbers}
{\mlton} has functions similar to the C {\tt rand} and {\tt srand} functions, as
well as support for access to {\tt /dev/random} and {\tt /dev/urandom}.

\feature{resource limits}
{\mlton} has functions similar to the C {\tt getrlimit} and {\tt
setrlimit} functions.

\feature{resource usage}
{\mlton} supports a subset of the functionality of the C {\tt getrusage}
function.

\feature{signal handlers}
{\mlton} supports signal handlers written in SML.  Signal handlers run
in a separate {\mlton} thread, and have access to the thread that was
interrupted by the signal.  Signal handlers can be used in conjunction
with threads to implement preemptive multitasking.

\feature{size primitive}
{\mlton} includes a primitive that returns the size (in bytes) of any
object.  This can be quite useful in understanding the space behavior
of a program.

\feature{system logging}
{\mlton} has a complete interface to the C {\tt syslog} function.

\feature{threads}
{\mlton} has support for its own threads, upon which either preemptive
or non-preemptive multitasking can be implemented.  At some point in
the future, {\mlton} will support CML.

\feature{weak pointers}
{\mlton} suports weak pointers, which allow the garbage collector to
reclaim objects that it would otherwise be forced to keep.  Weak
pointers are also used to provide finalization.

\feature{world save and restore}
{\mlton} has a facility for saving the entire state of a computation
to a file and restarting it later.  This facility can be used for
staging and for checkpointing computations.  It can even be used from
within signal handlers, allowing interrupt driven checkpointing.

\end{description}
\end{description}

