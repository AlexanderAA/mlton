<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta name="robots" content="index,nofollow">



<title>TypeIndexedValues - MLton Standard ML Compiler (SML Compiler)</title>
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="all" href="common.css">
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="screen" href="screen.css">
<link rel="stylesheet" type="text/css" charset="iso-8859-1" media="print" href="print.css">


<link rel="Start" href="Home">


</head>

<body lang="en" dir="ltr">

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-833377-1";
urchinTracker();
</script>
<table bgcolor = lightblue cellspacing = 0 style = "border: 0px;" width = 100%>
  <tr>
    <td style = "
		border: 0px;
		color: darkblue; 
		font-size: 150%;
		text-align: left;">
      <a class = mltona href="Home">MLton 20061025</a>
    <td style = "
		border: 0px;
		font-size: 150%;
		text-align: center;
		width: 50%;">
      TypeIndexedValues
    <td style = "
		border: 0px;
		text-align: right;">
      <table cellspacing = 0 style = "border: 0px">
        <tr style = "vertical-align: middle;">
      </table>
  <tr style = "background-color: white;">
    <td colspan = 3
	style = "
		border: 0px;
		font-size:70%;
		text-align: right;">
      <a href = "Home">Home</a>
      &nbsp;<a href = "Index">Index</a>
      &nbsp;
</table>
<div id="content" lang="en" dir="ltr">
<a href="StandardML">Standard ML</a> does not support ad hoc polymorphism.  This presents a challenge to programmers.  The problem is that at first glance there seems to be no practical way to implement something like a function for converting a value of any type to a string or a function for computing a hash value for a value of any type.  Fortunately there are ways to implement type-indexed values in SML as discussed in <a href = "References#Yang98">Yang98</a>. Various articles such as <a href = "References#Danvy98">Danvy98</a>, <a href = "References#Ramsey03">Ramsey03</a>, <a href = "References#Elsman04">Elsman04</a>, <a href = "References#Kennedy04">Kennedy04</a>, and <a href = "References#Benton05">Benton05</a> also contain examples of type-indexed values. <h2 id="head-2ea0b5ca6b0ef3808544cdd88ef0b644bbad42c4">Example: Converting any SML value to (roughly) SML syntax</h2>
<p>
<strong>NOTE:</strong> This is example is work-in-progress.  Please send your comments to the <a class="external" href="mailto:MLton-user@mlton.org"><img src="moin-email.png" alt="[MAILTO]" height="10" width="14">MLton-user@mlton.org</a> list. 
</p>
<p>
Consider the problem of converting any SML value to a textual presentation that matches the syntax of SML as closely as possible.  One solution is a type-indexed function that maps a given type to a function that maps any value (of the type) to its textual presentation.  A type-indexed function like this can be useful for a variety of purposes.  For example, one could use it to show debugging information.  We'll call this function "<tt>show</tt>". 
</p>
<p>
We'll do a fairly complete implementation of <tt>show</tt>.  We do not distinguish infix and nonfix constructors, but that is not an intrinsic property of SML datatypes.  We also don't reconstruct a type name for the value, although it would be particularly useful for functional values.  To reconstruct type names, some changes would be needed and the reader is encouraged to consider how to do that.  A more realistic implementation would use some pretty printing combinators to compute a layout for the result.  This should be a relatively easy change (given a suitable pretty printing library).  Cyclic values (through references and arrays) do not have a standard textual presentation and it is impossible to convert arbitrary functional values (within SML) to a meaningful textual presentation.  Finally, it would also make sense to show sharing of references and arrays.  We'll leave these improvements to an actual library implementation. 
</p>
<p>
We'll make use of the <a href="Fixpoints">fixpoint framework</a>, which is actually also a simple type-indexed function.  The following code assumes that the <tt>Fix</tt> structure and <a href="Utilities">utilities</a> are in scope. 
</p>
<h3 id="head-2f32be1dc74166373c988ec03b0bd86f0a576919">Signature</h3>
<p>
Let's consider the design of the <tt>SHOW</tt> signature: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">infixr</FONT></B> <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>

<B><FONT COLOR="#5F9EA0">signature</FONT></B> SHOW <B><FONT COLOR="#5F9EA0">=</FONT></B>
   <B><FONT COLOR="#5F9EA0">sig</FONT></B>
      <B><FONT COLOR="#A020F0">type</FONT></B> 'a t       <I><FONT COLOR="#B22222">(* complete type-index *)</FONT></I>
      <B><FONT COLOR="#A020F0">type</FONT></B> 'a s       <I><FONT COLOR="#B22222">(* incomplete sum *)</FONT></I>
      <B><FONT COLOR="#A020F0">type</FONT></B> ('a, 'k) p <I><FONT COLOR="#B22222">(* incomplete product *)</FONT></I>
      <B><FONT COLOR="#A020F0">type</FONT></B> u          <I><FONT COLOR="#B22222">(* tuple or unlabelled product *)</FONT></I>
      <B><FONT COLOR="#A020F0">type</FONT></B> l          <I><FONT COLOR="#B22222">(* record or labelled product *)</FONT></I>

      <B><FONT COLOR="#A020F0">val</FONT></B> show : 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#228B22">string</FONT></B>

      <I><FONT COLOR="#B22222">(* user-defined types *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> inj : ('a <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'b) <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'b t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t

      <I><FONT COLOR="#B22222">(* tuples and records *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#5F9EA0">*</FONT></B> : ('a, 'k) p <B><FONT COLOR="#5F9EA0">*</FONT></B> ('b, 'k) p <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (('a, 'b) product, 'k) p

      <B><FONT COLOR="#A020F0">val</FONT></B> U :           'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> ('a, u) p
      <B><FONT COLOR="#A020F0">val</FONT></B> L : <B><FONT COLOR="#228B22">string</FONT></B> <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> ('a, l) p

      <B><FONT COLOR="#A020F0">val</FONT></B> tuple  : ('a, u) p <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t
      <B><FONT COLOR="#A020F0">val</FONT></B> record : ('a, l) p <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t

      <I><FONT COLOR="#B22222">(* datatypes *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#5F9EA0">+</FONT></B> : 'a s <B><FONT COLOR="#5F9EA0">*</FONT></B> 'b s <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (('a, 'b) sum) s

      <B><FONT COLOR="#A020F0">val</FONT></B> C0 : <B><FONT COLOR="#228B22">string</FONT></B> <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B> s
      <B><FONT COLOR="#A020F0">val</FONT></B> C1 : <B><FONT COLOR="#228B22">string</FONT></B> <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a s

      <B><FONT COLOR="#A020F0">val</FONT></B> data : 'a s <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t

      <B><FONT COLOR="#A020F0">val</FONT></B> Y : 'a t Fix.t

      <I><FONT COLOR="#B22222">(* exceptions *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> exn : exn t
      <B><FONT COLOR="#A020F0">val</FONT></B> regExn : (exn <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> ('a <B><FONT COLOR="#5F9EA0">*</FONT></B> 'a s) option) effect

      <I><FONT COLOR="#B22222">(* some built-in type constructors *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> refc : 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a <B><FONT COLOR="#A020F0">ref</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">array</FONT></B> : 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a <B><FONT COLOR="#228B22">array</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">list</FONT></B> : 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a <B><FONT COLOR="#228B22">list</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">vector</FONT></B> : 'a t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a <B><FONT COLOR="#228B22">vector</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> : 'a t <B><FONT COLOR="#5F9EA0">*</FONT></B> 'b t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> ('a <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'b) t

      <I><FONT COLOR="#B22222">(* some built-in base types *)</FONT></I>
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">string</FONT></B> : <B><FONT COLOR="#228B22">string</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B> : <B><FONT COLOR="#228B22">unit</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> : <B><FONT COLOR="#228B22">bool</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> : <B><FONT COLOR="#228B22">char</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> : <B><FONT COLOR="#228B22">int</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">word</FONT></B> : <B><FONT COLOR="#228B22">word</FONT></B> t
      <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">real</FONT></B> : <B><FONT COLOR="#228B22">real</FONT></B> t
   <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
While some details are shaped by the specific requirements of <tt>show</tt>, there are a number of (design) patterns that translate to other type-indexed values.  The former kind of details are mostly shaped by the syntax of SML values that <tt>show</tt> is designed to produce.  To this end, abstract types and phantom types are used to distinguish incomplete record, tuple, and datatype type-indices from each other and from complete type-indices.  Also, names of record labels and datatype constructors need to be provided by the user. 
</p>
<h4 id="head-671800661391e0ee68700b83d223516c787ea4c9">Arbitrary user-defined datatypes</h4>
<p>
Perhaps the most important pattern is how the design supports arbitrary user-defined datatypes.  A number of combinators together conspire to provide the functionality.  First of all, to support new user-defined types, a combinator taking a conversion function to a previously supported type is provided: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> inj : ('a <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'b) <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'b t <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> 'a t
</PRE>
<p>
 
</p>
<p>
An injection function is sufficient in this case, but in the general case, an embedding with injection and projection functions may be needed. 
</p>
<p>
To support products (tuples and records) a product combinator is provided: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#5F9EA0">*</FONT></B> : ('a, 'k) p <B><FONT COLOR="#5F9EA0">*</FONT></B> ('b, 'k) p <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (('a, 'b) product, 'k) p
</PRE>
<p>
 
</p>
<p>
The second (phantom) type variable <tt>'k</tt> is there to distinguish between labelled and unlabelled products and the type <tt>p</tt> distinguishes incomplete products from complete type-indices of type <tt>t</tt>.  Most type-indexed values do not need to make such distinctions. 
</p>
<p>
To support sums (datatypes) a sum combinator is provided: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#5F9EA0">+</FONT></B> : 'a s <B><FONT COLOR="#5F9EA0">*</FONT></B> 'b s <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (('a, 'b) sum) s
</PRE>
<p>
 
</p>
<p>
Again, the purpose of the type <tt>s</tt> is to distinguish incomplete sums from complete type-indices of type <tt>t</tt>, which usually isn't necessary. 
</p>
<p>
Finally, to support recursive datatypes, including sets of mutually recursive datatypes, a <a href="Fixpoints">fixpoint tier</a> is provided: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> Y : 'a t Fix.t
</PRE>
<p>
 
</p>
<p>
Together these combinators (with the more domain specific combinators <tt>U</tt>, <tt>L</tt>, <tt>tuple</tt>, <tt>record</tt>, <tt>C0</tt>, <tt>C1</tt>, and <tt>data</tt>) enable one to encode a type-index for any user-defined datatype. 
</p>
<h4 id="head-cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723">Exceptions</h4>
<p>
The <tt>exn</tt> type in SML is a <a href="UniversalType">universal type</a> into which all types can be embedded.  SML also allows a program to generate new exception variants at run-time.  Thus a mechanism is required to register handlers for particular variants: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> exn : exn t
<B><FONT COLOR="#A020F0">val</FONT></B> regExn : (exn <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> ('a <B><FONT COLOR="#5F9EA0">*</FONT></B> 'a s) option) effect
</PRE>
<p>
 
</p>
<p>
The universal <tt>exn</tt> type-index then makes use of the registered handlers.  The above particular form of handler, which converts an exception value to a value of some type and a type-index for that type (essentially an existential type) is designed to make it convenient to write handlers.  To write a handler, one can conveniently reuse existing type-indices: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">exception</FONT></B> Int <B><FONT COLOR="#A020F0">of</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>

<B><FONT COLOR="#A020F0">local</FONT></B>
   <B><FONT COLOR="#A020F0">open</FONT></B> Show
<B><FONT COLOR="#A020F0">in</FONT></B>
   <B><FONT COLOR="#A020F0">val</FONT></B> () <B><FONT COLOR="#5F9EA0">=</FONT></B> regExn (<B><FONT COLOR="#A020F0">fn</FONT></B> Int v <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> (v, C1<B><FONT COLOR="#BC8F8F">&quot;Int&quot;</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>)
                     <B><FONT COLOR="#5F9EA0">|</FONT></B> _     <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B>)
<B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
Note that a single handler may actually handle an arbitrary number of different exceptions. 
</p>
<h4 id="head-8c5befcc2e0951ae7c577c186d5015110ab50c93">Other types</h4>
<p>
Some built-in and standard types typically require special treatment due to their special nature.  The most important of these are arrays and references, because cyclic data (ignoring closures) and observable sharing can only be constructed through them. 
</p>
<p>
When arrow types are really supported, unlike in this case, they usually need special treatment due to the contravariance of arguments. 
</p>
<p>
Lists and vectors require special treatment in the case of <tt>show</tt>, because of their special syntax.  This isn't usually the case. 
</p>
<p>
The set of base types to support also needs to be considered unless one exports an interface for constructing type-indices for entirely new base types. 
</p>
<h3 id="head-0bb18642b70b9f8a9c12ccf39487328f306b8e19">Usage</h3>
<p>
Before going to the implementation, let's look at some examples.  For the following examples, we'll assume a structure binding <tt>Show&nbsp;:&gt;&nbsp;SHOW</tt>. If you want to try the examples immediately, just skip forward to the implementation. 
</p>
<p>
To use <tt>show</tt>, one first needs a type-index, which is then given to <tt>show</tt>.  To show a list of integers, one would use the type-index <tt>list&nbsp;int</tt>, which has the type <tt>int&nbsp;list&nbsp;Show.t</tt>: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;[3, 1, 4]&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show (<B><FONT COLOR="#228B22">list</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) <B><FONT COLOR="#A020F0">end</FONT></B>
       [3, 1, 4]
</PRE>
<p>
 
</p>
<p>
Likewise, to show a list of lists of characters, one would use the type-index <tt>list&nbsp;(list&nbsp;char)</tt>, which has the type <tt>char&nbsp;list&nbsp;list&nbsp;Show.t</tt>: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;[[#\&quot;a\&quot;], [#\&quot;b\&quot;, #\&quot;c\&quot;], []]&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show (<B><FONT COLOR="#228B22">list</FONT></B> (<B><FONT COLOR="#228B22">list</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>)) <B><FONT COLOR="#A020F0">end</FONT></B>
       [[#<B><FONT COLOR="#BC8F8F">&quot;a&quot;</FONT></B>], [#<B><FONT COLOR="#BC8F8F">&quot;b&quot;</FONT></B>, #<B><FONT COLOR="#BC8F8F">&quot;c&quot;</FONT></B>], []]
</PRE>
<p>
 
</p>
<p>
Handling standard types is not particularly interesting.  It is more interesting to see how user-defined types can be handled.  Although the <tt>option</tt> datatype is a standard type, it requires no special support, so we can treat it as a user-defined type.  Options can be encoded easily using a sum: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">option</FONT></I></B></FONT></B> t <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Show
    <B><FONT COLOR="#A020F0">in</FONT></B>
       inj (<B><FONT COLOR="#A020F0">fn</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> INL ()
             <B><FONT COLOR="#5F9EA0">|</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> v <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> INR v)
           (data (C0<B><FONT COLOR="#BC8F8F">&quot;NONE&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">+</FONT></B> C1<B><FONT COLOR="#BC8F8F">&quot;SOME&quot;</FONT></B> t))
    <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;SOME 5&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show (option <B><FONT COLOR="#228B22">int</FONT></B>) <B><FONT COLOR="#A020F0">end</FONT></B>
       (<B><FONT COLOR="#5F9EA0">SOME</FONT></B> 5)
</PRE>
<p>
 
</p>
<p>
Readers new to type-indexed values might want to type annotate each subexpression of the above example as an exercise.  (Use a compiler to check your annotations.) 
</p>
<p>
Using a product, user specified records can be also be encoded easily: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> abc <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Show
    <B><FONT COLOR="#A020F0">in</FONT></B>
       inj (<B><FONT COLOR="#A020F0">fn</FONT></B> {a, b, c} <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> a &amp; b &amp; c)
           (record (L<B><FONT COLOR="#BC8F8F">&quot;a&quot;</FONT></B> (option <B><FONT COLOR="#228B22">int</FONT></B>) <B><FONT COLOR="#5F9EA0">*</FONT></B>
                    L<B><FONT COLOR="#BC8F8F">&quot;b&quot;</FONT></B> <B><FONT COLOR="#228B22">real</FONT></B> <B><FONT COLOR="#5F9EA0">*</FONT></B>
                    L<B><FONT COLOR="#BC8F8F">&quot;c&quot;</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B>))
    <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;{a = SOME 1, b = 3.0, c = false}&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show abc <B><FONT COLOR="#A020F0">end</FONT></B>
       {a <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> 1, b <B><FONT COLOR="#5F9EA0">=</FONT></B> 3.0, c <B><FONT COLOR="#5F9EA0">=</FONT></B> false}
</PRE>
<p>
 
</p>
<p>
As you can see, both of the above use <tt>inj</tt> to inject user-defined types to the general purpose sum and product types. 
</p>
<p>
Of particular interest is whether recursive datatypes and cyclic data can be handled.  For example, how does one write a type-index for a recursive datatype such as a cyclic graph? 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">datatype</FONT></B> 'a graph <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX <B><FONT COLOR="#A020F0">of</FONT></B> 'a <B><FONT COLOR="#5F9EA0">*</FONT></B> 'a graph <B><FONT COLOR="#228B22">list</FONT></B> <B><FONT COLOR="#A020F0">ref</FONT></B>
<B><FONT COLOR="#A020F0">fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">arcs</FONT></I></B></FONT></B> (VTX (_, r)) <B><FONT COLOR="#5F9EA0">=</FONT></B> r
</PRE>
<p>
 
</p>
<p>
Using the <tt>Show</tt> combinators, we could first write a new type-index combinator for <tt>graph</tt>: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">graph</FONT></I></B></FONT></B> a <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Fix Show
    <B><FONT COLOR="#A020F0">in</FONT></B>
       fix Y (<B><FONT COLOR="#A020F0">fn</FONT></B> graph_a <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                 inj (<B><FONT COLOR="#A020F0">fn</FONT></B> VTX (x, y) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> x &amp; y)
                     (data (C1<B><FONT COLOR="#BC8F8F">&quot;VTX&quot;</FONT></B>
                              (tuple (U a <B><FONT COLOR="#5F9EA0">*</FONT></B>
                                      U (refc (<B><FONT COLOR="#228B22">list</FONT></B> graph_a)))))))
    <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
To show a graph with integer labels 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> a_graph <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">val</FONT></B> a <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (1, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
       <B><FONT COLOR="#A020F0">val</FONT></B> b <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (2, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
       <B><FONT COLOR="#A020F0">val</FONT></B> c <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (3, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
       <B><FONT COLOR="#A020F0">val</FONT></B> d <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (4, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
       <B><FONT COLOR="#A020F0">val</FONT></B> e <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (5, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
       <B><FONT COLOR="#A020F0">val</FONT></B> f <B><FONT COLOR="#5F9EA0">=</FONT></B> VTX (6, <B><FONT COLOR="#A020F0">ref</FONT></B> [])
    <B><FONT COLOR="#A020F0">in</FONT></B>
       arcs a <B><FONT COLOR="#5F9EA0">:=</FONT></B> [b, d]
     ; arcs b <B><FONT COLOR="#5F9EA0">:=</FONT></B> [c, e]
     ; arcs c <B><FONT COLOR="#5F9EA0">:=</FONT></B> [a, f]
     ; arcs d <B><FONT COLOR="#5F9EA0">:=</FONT></B> [f]
     ; arcs e <B><FONT COLOR="#5F9EA0">:=</FONT></B> [d]
     ; arcs f <B><FONT COLOR="#5F9EA0">:=</FONT></B> [e]
     ; a
    <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
we could then simply write 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;VTX (1, ref [VTX (2, ref [VTX (3, ref [VTX (1, %0), \
    \VTX (6, ref [VTX (5, ref [VTX (4, ref [VTX (6, %3)])])] as %3)]), \
    \VTX (5, ref [VTX (4, ref [VTX (6, ref [VTX (5, %2)])])] as %2)]), \
    \VTX (4, ref [VTX (6, ref [VTX (5, ref [VTX (4, %1)])])] as %1)] as %0)&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show (graph <B><FONT COLOR="#228B22">int</FONT></B>) <B><FONT COLOR="#A020F0">end</FONT></B>
       a_graph
</PRE>
<p>
 
</p>
<p>
There is a subtle gotcha with cyclic data.  Consider the following code: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">exception</FONT></B> ExnArray <B><FONT COLOR="#A020F0">of</FONT></B> exn <B><FONT COLOR="#228B22">array</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> () <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Show
    <B><FONT COLOR="#A020F0">in</FONT></B>
       regExn (<B><FONT COLOR="#A020F0">fn</FONT></B> ExnArray a <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                  <B><FONT COLOR="#5F9EA0">SOME</FONT></B> (a, C1<B><FONT COLOR="#BC8F8F">&quot;ExnArray&quot;</FONT></B> (<B><FONT COLOR="#228B22">array</FONT></B> exn))
                <B><FONT COLOR="#5F9EA0">|</FONT></B> _ <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B>)
    <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> a_cycle <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">val</FONT></B> a <B><FONT COLOR="#5F9EA0">=</FONT></B> Array.fromList [Empty]
    <B><FONT COLOR="#A020F0">in</FONT></B>
       Array.update (a, 0, ExnArray a) ; a
    <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
<p>
Although the above looks innocent enough, the evaluation  of 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;[|ExnArray %0|] as %0&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show (<B><FONT COLOR="#228B22">array</FONT></B> exn) <B><FONT COLOR="#A020F0">end</FONT></B>
       a_cycle
</PRE>
<p>
 
</p>
<p>
goes into an infinite loop.  To avoid this problem, the type-index <tt>array&nbsp;exn</tt> must be evaluated only once, as in the following: 
</p>

<pre class=code>
<B><FONT COLOR="#A020F0">val</FONT></B> array_exn <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> <B><FONT COLOR="#228B22">array</FONT></B> exn <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">exception</FONT></B> ExnArray <B><FONT COLOR="#A020F0">of</FONT></B> exn <B><FONT COLOR="#228B22">array</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> () <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Show
    <B><FONT COLOR="#A020F0">in</FONT></B>
       regExn (<B><FONT COLOR="#A020F0">fn</FONT></B> ExnArray a <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                  <B><FONT COLOR="#5F9EA0">SOME</FONT></B> (a, C1<B><FONT COLOR="#BC8F8F">&quot;ExnArray&quot;</FONT></B> array_exn)
                <B><FONT COLOR="#5F9EA0">|</FONT></B> _ <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B>)
    <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> a_cycle <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">val</FONT></B> a <B><FONT COLOR="#5F9EA0">=</FONT></B> Array.fromList [Empty]
    <B><FONT COLOR="#A020F0">in</FONT></B>
       Array.update (a, 0, ExnArray a) ; a
    <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;[|ExnArray %0|] as %0&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B> <B><FONT COLOR="#A020F0">open</FONT></B> Show <B><FONT COLOR="#A020F0">in</FONT></B> show array_exn <B><FONT COLOR="#A020F0">end</FONT></B>
       a_cycle
</PRE>
<p>
 
</p>
<p>
Cyclic data (excluding closures) in Standard ML can only be constructed imperatively through arrays and references (combined with exceptions or recursive datatypes).  Before recursing to a reference or an array, one needs to check whether that reference or array has already been seen before.  When <tt>ref</tt> or <tt>array</tt> is called with a type-index, a new cyclicity checker is instantiated. 
</p>
<h3 id="head-8781d615fd77be9578225c40ac67b9471394cced">Implementation</h3>

<pre class=code>
<B><FONT COLOR="#5F9EA0">structure</FONT></B> SmlSyntax <B><FONT COLOR="#5F9EA0">=</FONT></B>
   <B><FONT COLOR="#5F9EA0">struct</FONT></B>
      <B><FONT COLOR="#A020F0">local</FONT></B>
         <B><FONT COLOR="#5F9EA0">structure</FONT></B> CV <B><FONT COLOR="#5F9EA0">=</FONT></B> CharVector <B><FONT COLOR="#A020F0">and</FONT></B> C <B><FONT COLOR="#5F9EA0">=</FONT></B> Char
      <B><FONT COLOR="#A020F0">in</FONT></B>
         <B><FONT COLOR="#A020F0">val</FONT></B> isSym <B><FONT COLOR="#5F9EA0">=</FONT></B> Char.contains <B><FONT COLOR="#BC8F8F">&quot;!%&amp;$#+-/:&lt;=&gt;?@\\~`^|*&quot;</FONT></B>

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isSymId</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B> 0 &lt; size s <B><FONT COLOR="#A020F0">andalso</FONT></B> CV.all isSym s

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isAlphaNumId</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B>
             0 &lt; size s
             <B><FONT COLOR="#A020F0">andalso</FONT></B> C.isAlpha (CV.sub (s, 0))
             <B><FONT COLOR="#A020F0">andalso</FONT></B> CV.all (<B><FONT COLOR="#A020F0">fn</FONT></B> c <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> C.isAlphaNum c
                                     <B><FONT COLOR="#A020F0">orelse</FONT></B> #<B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> c
                                     <B><FONT COLOR="#A020F0">orelse</FONT></B> #<B><FONT COLOR="#BC8F8F">&quot;_&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> c) s

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isNumLabel</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B>
             0 &lt; size s
             <B><FONT COLOR="#A020F0">andalso</FONT></B> #<B><FONT COLOR="#BC8F8F">&quot;0&quot;</FONT></B> <B><FONT COLOR="#5F9EA0">&lt;&gt;</FONT></B> CV.sub (s, 0)
             <B><FONT COLOR="#A020F0">andalso</FONT></B> CV.all C.isDigit s

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isId</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B> isAlphaNumId s <B><FONT COLOR="#A020F0">orelse</FONT></B> isSymId s

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isLongId</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B> List.all isId (String.fields (#<B><FONT COLOR="#BC8F8F">&quot;.&quot;</FONT></B> &lt;\ <B><FONT COLOR="#A020F0">op</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>) s)

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">isLabel</FONT></I></B></FONT></B> s <B><FONT COLOR="#5F9EA0">=</FONT></B> isId s <B><FONT COLOR="#A020F0">orelse</FONT></B> isNumLabel s
      <B><FONT COLOR="#A020F0">end</FONT></B>
   <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#5F9EA0">structure</FONT></B> Show :<B><FONT COLOR="#5F9EA0">&gt;</FONT></B> SHOW <B><FONT COLOR="#5F9EA0">=</FONT></B>
   <B><FONT COLOR="#5F9EA0">struct</FONT></B>
      <B><FONT COLOR="#A020F0">datatype</FONT></B> 'a t <B><FONT COLOR="#5F9EA0">=</FONT></B> IN <B><FONT COLOR="#A020F0">of</FONT></B> exn <B><FONT COLOR="#228B22">list</FONT></B> <B><FONT COLOR="#5F9EA0">*</FONT></B> 'a <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#5F9EA0">*</FONT></B> <B><FONT COLOR="#228B22">string</FONT></B>
      <B><FONT COLOR="#A020F0">type</FONT></B> 'a s <B><FONT COLOR="#5F9EA0">=</FONT></B> 'a t
      <B><FONT COLOR="#A020F0">type</FONT></B> ('a, 'k) p <B><FONT COLOR="#5F9EA0">=</FONT></B> 'a t
      <B><FONT COLOR="#A020F0">type</FONT></B> u <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B>
      <B><FONT COLOR="#A020F0">type</FONT></B> l <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B>

<B><FONT COLOR="#A020F0">      fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">show</FONT></I></B></FONT></B> (IN t) x <B><FONT COLOR="#5F9EA0">=</FONT></B> #2 (t ([], x))

      <I><FONT COLOR="#B22222">(* user-defined types *)</FONT></I>
<B><FONT COLOR="#A020F0">      fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">inj</FONT></I></B></FONT></B> inj (IN b) <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (b <B><FONT COLOR="#A020F0">o</FONT></B> cross (id, inj))

      <B><FONT COLOR="#A020F0">local</FONT></B>
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">surround</FONT></I></B></FONT></B> pre suf (_, s) <B><FONT COLOR="#5F9EA0">=</FONT></B> (false, <B><FONT COLOR="#A020F0">concat</FONT></B> [pre, s, suf])
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">parenthesize</FONT></I></B></FONT></B> x <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> #1 x <B><FONT COLOR="#A020F0">then</FONT></B> surround <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B> x <B><FONT COLOR="#A020F0">else</FONT></B> x
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">construct</FONT></I></B></FONT></B> tag <B><FONT COLOR="#5F9EA0">=</FONT></B>
             (<B><FONT COLOR="#A020F0">fn</FONT></B> (_, s) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (true, <B><FONT COLOR="#A020F0">concat</FONT></B> [tag, <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>, s])) <B><FONT COLOR="#A020F0">o</FONT></B> parenthesize
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">check</FONT></I></B></FONT></B> p m s <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> p s <B><FONT COLOR="#A020F0">then</FONT></B> () <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">raise</FONT></B> Fail (m<B><FONT COLOR="#5F9EA0">^</FONT></B>s)
      <B><FONT COLOR="#A020F0">in</FONT></B>
         <I><FONT COLOR="#B22222">(* tuples and records *)</FONT></I>
         <B><FONT COLOR="#A020F0">fun</FONT></B> (IN l) <B><FONT COLOR="#5F9EA0">*</FONT></B> (IN r) <B><FONT COLOR="#5F9EA0">=</FONT></B>
             IN (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, a &amp; b) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                    (false, <B><FONT COLOR="#A020F0">concat</FONT></B> [#2 (l (rs, a)),
                                    <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B>,
                                    #2 (r (rs, b))]))

         <B><FONT COLOR="#A020F0">val</FONT></B> U <B><FONT COLOR="#5F9EA0">=</FONT></B> id
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">L</FONT></I></B></FONT></B> l <B><FONT COLOR="#5F9EA0">=</FONT></B> (check SmlSyntax.isLabel <B><FONT COLOR="#BC8F8F">&quot;Invalid label: &quot;</FONT></B> l
                  ; <B><FONT COLOR="#A020F0">fn</FONT></B> IN t <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> IN (surround (l<B><FONT COLOR="#5F9EA0">^</FONT></B><B><FONT COLOR="#BC8F8F">&quot; = &quot;</FONT></B>) <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> t))

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">tuple</FONT></I></B></FONT></B> (IN t) <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (surround <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> t)
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">record</FONT></I></B></FONT></B> (IN t) <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (surround <B><FONT COLOR="#BC8F8F">&quot;{&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;}&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> t)

         <I><FONT COLOR="#B22222">(* datatypes *)</FONT></I>
         <B><FONT COLOR="#A020F0">fun</FONT></B> (IN l) <B><FONT COLOR="#5F9EA0">+</FONT></B> (IN r) <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, INL a) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> l (rs, a)
                                    <B><FONT COLOR="#5F9EA0">|</FONT></B> (rs, INR b) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> r (rs, b))

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">C0</FONT></I></B></FONT></B> c <B><FONT COLOR="#5F9EA0">=</FONT></B> (check SmlSyntax.isId <B><FONT COLOR="#BC8F8F">&quot;Invalid constructor: &quot;</FONT></B> c
                   ; IN (const (false, c)))
<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">C1</FONT></I></B></FONT></B> c (IN t) <B><FONT COLOR="#5F9EA0">=</FONT></B> (check SmlSyntax.isId <B><FONT COLOR="#BC8F8F">&quot;Invalid constructor: &quot;</FONT></B> c
                          ; IN (construct c <B><FONT COLOR="#A020F0">o</FONT></B> t))

         <B><FONT COLOR="#A020F0">val</FONT></B> data <B><FONT COLOR="#5F9EA0">=</FONT></B> id

<B><FONT COLOR="#A020F0">         fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">Y</FONT></I></B></FONT></B> ? <B><FONT COLOR="#5F9EA0">=</FONT></B> Fix.iso (IN, <B><FONT COLOR="#A020F0">fn</FONT></B> IN x <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> x) Fn.Y ?

         <I><FONT COLOR="#B22222">(* exceptions *)</FONT></I>
         <B><FONT COLOR="#A020F0">local</FONT></B>
            <B><FONT COLOR="#A020F0">val</FONT></B> handlers <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#A020F0">ref</FONT></B> ([] : (exn <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B> t option) <B><FONT COLOR="#228B22">list</FONT></B>)
         <B><FONT COLOR="#A020F0">in</FONT></B>
            <B><FONT COLOR="#A020F0">val</FONT></B> exn <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, e) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                             <B><FONT COLOR="#A020F0">let</FONT></B>
<B><FONT COLOR="#A020F0">                                fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">lp</FONT></I></B></FONT></B> [] <B><FONT COLOR="#5F9EA0">=</FONT></B>
                                    C0(<B><FONT COLOR="#A020F0">concat</FONT></B> [<B><FONT COLOR="#BC8F8F">&quot;&lt;exn:&quot;</FONT></B>,
                                               General.exnName e,
                                               <B><FONT COLOR="#BC8F8F">&quot;&gt;&quot;</FONT></B>])
                                  <B><FONT COLOR="#5F9EA0">|</FONT></B> lp (f<B><FONT COLOR="#5F9EA0">::</FONT></B>fs) <B><FONT COLOR="#5F9EA0">=</FONT></B>
                                    <B><FONT COLOR="#A020F0">case</FONT></B> f e <B><FONT COLOR="#A020F0">of</FONT></B>
                                       <B><FONT COLOR="#5F9EA0">NONE</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> lp fs
                                     <B><FONT COLOR="#5F9EA0">|</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> t <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> t
                                <B><FONT COLOR="#A020F0">val</FONT></B> IN f <B><FONT COLOR="#5F9EA0">=</FONT></B> lp (<B><FONT COLOR="#5F9EA0">!</FONT></B>handlers)
                             <B><FONT COLOR="#A020F0">in</FONT></B>
                                f (rs, ())
                             <B><FONT COLOR="#A020F0">end</FONT></B>)
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">regExn</FONT></I></B></FONT></B> f <B><FONT COLOR="#5F9EA0">=</FONT></B>
                handlers <B><FONT COLOR="#5F9EA0">:=</FONT></B> (Option.map
                                (<B><FONT COLOR="#A020F0">fn</FONT></B> (x, IN f) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                                    IN (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, ()) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                                           f (rs, x))) <B><FONT COLOR="#A020F0">o</FONT></B> f)
                            <B><FONT COLOR="#5F9EA0">::</FONT></B> <B><FONT COLOR="#5F9EA0">!</FONT></B>handlers
         <B><FONT COLOR="#A020F0">end</FONT></B>

         <I><FONT COLOR="#B22222">(* some built-in type constructors *)</FONT></I>
         <B><FONT COLOR="#A020F0">local</FONT></B>
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">cyclic</FONT></I></B></FONT></B> (IN t) <B><FONT COLOR="#5F9EA0">=</FONT></B>
                <B><FONT COLOR="#A020F0">let</FONT></B>
                   <B><FONT COLOR="#A020F0">exception</FONT></B> E <B><FONT COLOR="#A020F0">of</FONT></B> ''a <B><FONT COLOR="#5F9EA0">*</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">ref</FONT></B>
                <B><FONT COLOR="#A020F0">in</FONT></B>
                   IN (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, v : ''a) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                          <B><FONT COLOR="#A020F0">let</FONT></B>
                             <B><FONT COLOR="#A020F0">val</FONT></B> idx <B><FONT COLOR="#5F9EA0">=</FONT></B> Int.toString <B><FONT COLOR="#A020F0">o</FONT></B> length
<B><FONT COLOR="#A020F0">                             fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">lp</FONT></I></B></FONT></B> (E (v', c)<B><FONT COLOR="#5F9EA0">::</FONT></B>rs) <B><FONT COLOR="#5F9EA0">=</FONT></B>
                                 <B><FONT COLOR="#A020F0">if</FONT></B> v' <B><FONT COLOR="#5F9EA0">&lt;&gt;</FONT></B> v <B><FONT COLOR="#A020F0">then</FONT></B> lp rs
                                 <B><FONT COLOR="#A020F0">else</FONT></B> (c <B><FONT COLOR="#5F9EA0">:=</FONT></B> false ; (false, <B><FONT COLOR="#BC8F8F">&quot;%&quot;</FONT></B><B><FONT COLOR="#5F9EA0">^</FONT></B>idx rs))
                               <B><FONT COLOR="#5F9EA0">|</FONT></B> lp (_<B><FONT COLOR="#5F9EA0">::</FONT></B>rs) <B><FONT COLOR="#5F9EA0">=</FONT></B> lp rs
                               <B><FONT COLOR="#5F9EA0">|</FONT></B> lp [] <B><FONT COLOR="#5F9EA0">=</FONT></B>
                                 <B><FONT COLOR="#A020F0">let</FONT></B>
                                    <B><FONT COLOR="#A020F0">val</FONT></B> c <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#A020F0">ref</FONT></B> true
                                    <B><FONT COLOR="#A020F0">val</FONT></B> r <B><FONT COLOR="#5F9EA0">=</FONT></B> t (E (v, c)<B><FONT COLOR="#5F9EA0">::</FONT></B>rs, v)
                                 <B><FONT COLOR="#A020F0">in</FONT></B>
                                    <B><FONT COLOR="#A020F0">if</FONT></B> <B><FONT COLOR="#5F9EA0">!</FONT></B>c <B><FONT COLOR="#A020F0">then</FONT></B>
                                       r
                                    <B><FONT COLOR="#A020F0">else</FONT></B>
                                       surround <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> (<B><FONT COLOR="#BC8F8F">&quot; as %&quot;</FONT></B><B><FONT COLOR="#5F9EA0">^</FONT></B>idx rs) r
                                 <B><FONT COLOR="#A020F0">end</FONT></B>
                          <B><FONT COLOR="#A020F0">in</FONT></B>
                             lp rs
                          <B><FONT COLOR="#A020F0">end</FONT></B>)
                <B><FONT COLOR="#A020F0">end</FONT></B>

<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">aggregate</FONT></I></B></FONT></B> pre suf toList (IN t) <B><FONT COLOR="#5F9EA0">=</FONT></B>
                IN (surround pre suf <B><FONT COLOR="#A020F0">o</FONT></B>
                    (<B><FONT COLOR="#A020F0">fn</FONT></B> (rs, a) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B>
                        (false,
                         String.concatWith
                            <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B>
                            (map (#2 <B><FONT COLOR="#A020F0">o</FONT></B> curry t rs)
                                 (toList a)))))

         <B><FONT COLOR="#A020F0">in</FONT></B>
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">refc</FONT></I></B></FONT></B> ? <B><FONT COLOR="#5F9EA0">=</FONT></B> (cyclic <B><FONT COLOR="#A020F0">o</FONT></B> inj <B><FONT COLOR="#5F9EA0">!</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> C1<B><FONT COLOR="#BC8F8F">&quot;ref&quot;</FONT></B>) ?
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">array</FONT></I></B></FONT></B> ? <B><FONT COLOR="#5F9EA0">=</FONT></B> (cyclic <B><FONT COLOR="#A020F0">o</FONT></B> aggregate <B><FONT COLOR="#BC8F8F">&quot;[|&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;|]&quot;</FONT></B> (Array.foldr <B><FONT COLOR="#A020F0">op</FONT></B><B><FONT COLOR="#5F9EA0">::</FONT></B> [])) ?
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">list</FONT></I></B></FONT></B> ? <B><FONT COLOR="#5F9EA0">=</FONT></B> aggregate <B><FONT COLOR="#BC8F8F">&quot;[&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;]&quot;</FONT></B> id ?
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">vector</FONT></I></B></FONT></B> ? <B><FONT COLOR="#5F9EA0">=</FONT></B> aggregate <B><FONT COLOR="#BC8F8F">&quot;#[&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;]&quot;</FONT></B> (Vector.foldr <B><FONT COLOR="#A020F0">op</FONT></B><B><FONT COLOR="#5F9EA0">::</FONT></B> []) ?
         <B><FONT COLOR="#A020F0">end</FONT></B>

         <B><FONT COLOR="#A020F0">fun</FONT></B> (IN _) <B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">-</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (IN _) <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (const (false, <B><FONT COLOR="#BC8F8F">&quot;&lt;fn&gt;&quot;</FONT></B>))

         <I><FONT COLOR="#B22222">(* some built-in base types *)</FONT></I>
         <B><FONT COLOR="#A020F0">local</FONT></B>
<B><FONT COLOR="#A020F0">            fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">mk</FONT></I></B></FONT></B> toS <B><FONT COLOR="#5F9EA0">=</FONT></B> (<B><FONT COLOR="#A020F0">fn</FONT></B> x <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> (false, x)) <B><FONT COLOR="#A020F0">o</FONT></B> toS <B><FONT COLOR="#A020F0">o</FONT></B> (<B><FONT COLOR="#A020F0">fn</FONT></B> (_, x) <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> x)
         <B><FONT COLOR="#A020F0">in</FONT></B>
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">string</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B>
                IN (surround <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> mk (String.translate Char.toString))
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">unit</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (mk (<B><FONT COLOR="#A020F0">fn</FONT></B> () <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;()&quot;</FONT></B>))
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (mk Bool.toString)
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (surround <B><FONT COLOR="#BC8F8F">&quot;#\&quot;&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;\&quot;&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> mk Char.toString)
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (mk Int.toString)
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">word</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (surround <B><FONT COLOR="#BC8F8F">&quot;0wx&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> <B><FONT COLOR="#A020F0">o</FONT></B> mk Word.toString)
            <B><FONT COLOR="#A020F0">val</FONT></B> <B><FONT COLOR="#228B22">real</FONT></B> <B><FONT COLOR="#5F9EA0">=</FONT></B> IN (mk Real.toString)
         <B><FONT COLOR="#A020F0">end</FONT></B>
      <B><FONT COLOR="#A020F0">end</FONT></B>
   <B><FONT COLOR="#A020F0">end</FONT></B>

<I><FONT COLOR="#B22222">(* Handlers for standard top-level exceptions *)</FONT></I>
<B><FONT COLOR="#A020F0">val</FONT></B> () <B><FONT COLOR="#5F9EA0">=</FONT></B>
    <B><FONT COLOR="#A020F0">let</FONT></B>
       <B><FONT COLOR="#A020F0">open</FONT></B> Show
<B><FONT COLOR="#A020F0">       fun </FONT></B><B><FONT COLOR="#0000FF"><B><I><FONT COLOR="#000000">E0</FONT></I></B></FONT></B> name <B><FONT COLOR="#5F9EA0">=</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> ((), C0 name)
    <B><FONT COLOR="#A020F0">in</FONT></B>
       regExn (<B><FONT COLOR="#A020F0">fn</FONT></B> Bind <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Bind&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Chr <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Chr&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Div <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Div&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Domain <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Domain&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Empty <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Empty&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Match <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Match&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Option <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Option&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Overflow  <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Overflow&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Size <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Size&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Span <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Span&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> Subscript <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> E0<B><FONT COLOR="#BC8F8F">&quot;Subscript&quot;</FONT></B>
                <B><FONT COLOR="#5F9EA0">|</FONT></B> _ <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B>)
     ; regExn (<B><FONT COLOR="#A020F0">fn</FONT></B> Fail s <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">SOME</FONT></B> (s, C1<B><FONT COLOR="#BC8F8F">&quot;Fail&quot;</FONT></B> <B><FONT COLOR="#228B22">string</FONT></B>)
                <B><FONT COLOR="#5F9EA0">|</FONT></B> _ <B><FONT COLOR="#5F9EA0">=</FONT></B><B><FONT COLOR="#5F9EA0">&gt;</FONT></B> <B><FONT COLOR="#5F9EA0">NONE</FONT></B>)
    <B><FONT COLOR="#A020F0">end</FONT></B>
</PRE>
<p>
 
</p>
</div>



<p>
<hr>
Last edited on 2006-08-13 15:03:53 by <span title="cs181143070.pp.htv.fi"><a href="VesaKarvonen">VesaKarvonen</a></span>.
</body></html>
